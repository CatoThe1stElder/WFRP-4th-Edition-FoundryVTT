CONFIG.statusEffects =
["systems/wfrp4e/icons/conditions/bleeding1.png",
"systems/wfrp4e/icons/conditions/bleeding2.png",
"systems/wfrp4e/icons/conditions/bleeding3.png",
"systems/wfrp4e/icons/conditions/bleeding4.png",
"systems/wfrp4e/icons/conditions/poisoned1.png",
"systems/wfrp4e/icons/conditions/poisoned2.png",
"systems/wfrp4e/icons/conditions/poisoned3.png",
"systems/wfrp4e/icons/conditions/poisoned4.png",
"systems/wfrp4e/icons/conditions/ablaze1.png",
"systems/wfrp4e/icons/conditions/ablaze2.png",
"systems/wfrp4e/icons/conditions/ablaze3.png",
"systems/wfrp4e/icons/conditions/ablaze4.png",
"systems/wfrp4e/icons/conditions/deafened1.png",
"systems/wfrp4e/icons/conditions/deafened2.png",
"systems/wfrp4e/icons/conditions/deafened3.png",
"systems/wfrp4e/icons/conditions/deafened4.png",
"systems/wfrp4e/icons/conditions/stunned1.png",
"systems/wfrp4e/icons/conditions/stunned2.png",
"systems/wfrp4e/icons/conditions/stunned3.png",
"systems/wfrp4e/icons/conditions/stunned4.png",
"systems/wfrp4e/icons/conditions/entangled1.png",
"systems/wfrp4e/icons/conditions/entangled2.png",
"systems/wfrp4e/icons/conditions/entangled3.png",
"systems/wfrp4e/icons/conditions/entangled4.png",
"systems/wfrp4e/icons/conditions/fatigued1.png",
"systems/wfrp4e/icons/conditions/fatigued2.png",
"systems/wfrp4e/icons/conditions/fatigued3.png",
"systems/wfrp4e/icons/conditions/fatigued4.png",
"systems/wfrp4e/icons/conditions/blinded1.png",
"systems/wfrp4e/icons/conditions/blinded2.png",
"systems/wfrp4e/icons/conditions/blinded3.png",
"systems/wfrp4e/icons/conditions/blinded4.png",
"systems/wfrp4e/icons/conditions/broken1.png",
"systems/wfrp4e/icons/conditions/broken2.png",
"systems/wfrp4e/icons/conditions/broken3.png",
"systems/wfrp4e/icons/conditions/broken4.png",
"systems/wfrp4e/icons/conditions/grappling.png",
"systems/wfrp4e/icons/conditions/prone.png",
"systems/wfrp4e/icons/conditions/fear.png",
"systems/wfrp4e/icons/conditions/surprised.png",
]

CONFIG.Token = { defeatedIcon : "systems/wfrp4e/icons/defeated.png"};

 CONFIG.JournalEntry.noteIcons = {
   "Marker" : "systems/wfrp4e/icons/buildings/point_of_interest.png",
   "Apothecary" : "systems/wfrp4e/icons/buildings/apothecary.png",
   "Beastmen Herd 1" : "systems/wfrp4e/icons/buildings/beastmen_camp1.png",
   "Besatmen Herd 2" : "systems/wfrp4e/icons/buildings/beastmen_camp2.png",
   "Blacksmith" : "systems/wfrp4e/icons/buildings/blacksmith.png",
   "Bretonnian City 1" : "systems/wfrp4e/icons/buildings/bret_city1.png",
   "Bretonnian City 2" : "systems/wfrp4e/icons/buildings/bret_city2.png",
   "Bretonnian City 3" : "systems/wfrp4e/icons/buildings/bret_city3.png",
   "Bretonnian Worship" : "systems/wfrp4e/icons/buildings/bretonnia_worship.png",
   "Caste Hill 1" : "systems/wfrp4e/icons/buildings/castle_hill1.png",
   "Caste Hill 2" : "systems/wfrp4e/icons/buildings/castle_hill2.png",
   "Caste Hill 3" : "systems/wfrp4e/icons/buildings/castle_hill3.png",
   "Castle Wall" : "systems/wfrp4e/icons/buildings/castle_wall.png",
   "Cave 1" : "systems/wfrp4e/icons/buildings/cave1.png",
   "Cave 2" : "systems/wfrp4e/icons/buildings/cave2.png",
   "Cave 3" : "systems/wfrp4e/icons/buildings/cave3.png",
   "Cemetery" : "systems/wfrp4e/icons/buildings/cemetery.png",
   "Chaos Portal" : "systems/wfrp4e/icons/buildings/chaos_portal.png",
   "Chaos Worship" : "systems/wfrp4e/icons/buildings/chaos_worship.png",
   "Court" : "systems/wfrp4e/icons/buildings/court.png",
   "Dwarf Beer" : "systems/wfrp4e/icons/buildings/dwarf_beer.png",
   "Dwarf Hold 1" : "systems/wfrp4e/icons/buildings/dwarf_hold1.png",
   "Dwarf Hold 2" : "systems/wfrp4e/icons/buildings/dwarf_hold2.png",
   "Dwarf Hold 3" : "systems/wfrp4e/icons/buildings/dwarf_hold3.png",
   "Empire Barracks" : "systems/wfrp4e/icons/buildings/empire_barracks.png",
   "Empire City 1" : "systems/wfrp4e/icons/buildings/empire_city1.png",
   "Empire City 2" : "systems/wfrp4e/icons/buildings/empire_city2.png",
   "Empire City 3" : "systems/wfrp4e/icons/buildings/empire_city3.png",
   "Farm" : "systems/wfrp4e/icons/buildings/farms.png",
   "Food" : "systems/wfrp4e/icons/buildings/food.png",
   "Guard Post" : "systems/wfrp4e/icons/buildings/guards.png",
   "Haunted Hill" : "systems/wfrp4e/icons/buildings/haunted_hill.png",
   "Haunted Wood" : "systems/wfrp4e/icons/buildings/haunted_wood.png",
   "Inn 1" : "systems/wfrp4e/icons/buildings/inn1.png",
   "Inn 2" : "systems/wfrp4e/icons/buildings/inn2.png",
   "Kislev City 1" : "systems/wfrp4e/icons/buildings/kislev_city1.png",
   "Kislev City 2" : "systems/wfrp4e/icons/buildings/kislev_city2.png",
   "Kislev City 3" : "systems/wfrp4e/icons/buildings/kislev_city3.png",
   "Lumber" : "systems/wfrp4e/icons/buildings/lumber.png",
   "Magic" : "systems/wfrp4e/icons/buildings/magic.png",
   "Metal" : "systems/wfrp4e/icons/buildings/metal.png",
   "Mountain 1" : "systems/wfrp4e/icons/buildings/mountains1.png",
   "Mountain 2" : "systems/wfrp4e/icons/buildings/mountains2.png",
   "Orcs" : "systems/wfrp4e/icons/buildings/orcs.png",
   "Orc Camp" : "systems/wfrp4e/icons/buildings/orc_city.png",
   "Port" : "systems/wfrp4e/icons/buildings/port.png",
   "Road" : "systems/wfrp4e/icons/buildings/roads.png",
   "Ruins" : "systems/wfrp4e/icons/buildings/ruins.png",
   "Scroll" : "systems/wfrp4e/icons/buildings/scroll.png",
   "Sigmar" : "systems/wfrp4e/icons/buildings/sigmar_worship.png",
   "Stables" : "systems/wfrp4e/icons/buildings/stables.png",
   "Standing Stones" : "systems/wfrp4e/icons/buildings/standing_stones.png",
   "Swamp" : "systems/wfrp4e/icons/buildings/swamp.png",
   "Temple" : "systems/wfrp4e/icons/buildings/temple.png",
   "Textile" : "systems/wfrp4e/icons/buildings/textile.png",
   "Tower 1" : "systems/wfrp4e/icons/buildings/tower1.png",
   "Tower 2" : "systems/wfrp4e/icons/buildings/tower2.png",
   "Tower Hill" : "systems/wfrp4e/icons/buildings/tower_hill.png",
   "Wizard Tower" : "systems/wfrp4e/icons/buildings/wizard_tower.png",
   "Ulric" : "systems/wfrp4e/icons/buildings/ulric_worship.png",
   "Village 1" : "systems/wfrp4e/icons/buildings/village1.png",
   "Village 2" : "systems/wfrp4e/icons/buildings/village2.png",
   "Village 3" : "systems/wfrp4e/icons/buildings/village3.png",
   "Wood Elves 1" : "systems/wfrp4e/icons/buildings/welves1.png",
   "Wood Elves 2" : "systems/wfrp4e/icons/buildings/welves2.png",
   "Wood Elves 3" : "systems/wfrp4e/icons/buildings/welves3.png"
 }

// Species
CONFIG.species = {
  "human": "Human",
  "dwarf": "Dwarf",
  "halfling": "Halfling",
  "helf": "High Elf",
  "welf": "Wood Elf",
};

CONFIG.speciesCharacteristics = {
  "human" :
  {
   "ws" : "2d10+20",
   "bs" : "2d10+20",
   "s"  : "2d10+20",
   "t"  : "2d10+20",
   "i"  : "2d10+20",
   "ag" : "2d10+20",
   "dex": "2d10+20",
   "int": "2d10+20",
   "wp" : "2d10+20",
   "fel": "2d10+20"
  },
  "dwarf" :
  {
    "ws" : "2d10+30",
    "bs" : "2d10+20",
    "s"  : "2d10+20",
    "t"  : "2d10+30",
    "i"  : "2d10+20",
    "ag" : "2d10+10",
    "dex": "2d10+30",
    "int": "2d10+20",
    "wp" : "2d10+40",
    "fel": "2d10+10"
  },
  "halfling" :
  {
    "ws" : "2d10+10",
    "bs" : "2d10+30",
    "s"  : "2d10+10",
    "t"  : "2d10+20",
    "i"  : "2d10+20",
    "ag" : "2d10+20",
    "dex": "2d10+30",
    "int": "2d10+20",
    "wp" : "2d10+30",
    "fel": "2d10+30"
  },
  "helf" :
  {
    "ws" : "2d10+30",
    "bs" : "2d10+30",
    "s"  : "2d10+20",
    "t"  : "2d10+20",
    "i"  : "2d10+40",
    "ag" : "2d10+30",
    "dex": "2d10+30",
    "int": "2d10+30",
    "wp" : "2d10+30",
    "fel": "2d10+20"
  },
  "welf" :
  {
    "ws" : "2d10+30",
    "bs" : "2d10+30",
    "s"  : "2d10+20",
    "t"  : "2d10+20",
    "i"  : "2d10+40",
    "ag" : "2d10+30",
    "dex": "2d10+30",
    "int": "2d10+30",
    "wp" : "2d10+30",
    "fel": "2d10+20"
  },

}

CONFIG.speciesSkills = {
  "human" : [
    "Animal Care",
    "Charm",
    "Cool",
    "Evaluate",
    "Gossip",
    "Haggle",
    "Language (Bretonnian)",
    "Language (Wastelander)",
    "Leadership",
    "Lore (Reikland)",
    "Melee (Basic)",
    "Ranged (Bow)"
  ],
  "dwarf" : [
    "Consume Alcohol",
    "Cool",
    "Endurance",
    "Entertain (Storytelling)",
    "Evaluate",
    "Intimidate",
    "Language (Khazalid)",
    "Lore (Dwarfs)",
    "Lore (Geology)",
    "Lore (Metallurgy)",
    "Melee (Basic)",
    "Trade (any one)"
  ],
  "halfling" : [
    "Charm",
    "Consume Alcohol",
    "Dodge",
    "Gamble",
    "Haggle",
    "Intuition",
    "Language (Mootish)",
    "Lore (Reikland)",
    "Lore (Perception)",
    "Sleight of Hand",
    "Stealth (Any)",
    "Trade (Cook)"
  ],
  "helf" : [
    "Cool",
    "Entertain (Sing)",
    "Evaluate",
    "Language (Eltharin)",
    "Leadership",
    "Melee (Basic)",
    "Navigation",
    "Perception",
    "Play (any one)",
    "Ranged (Bow)",
    "Sail",
    "Swim"
  ],
  "welf" : [
    "Athletics",
    "Climb",
    "Endurance",
    "Entertain (Sing)",
    "Intimidate",
    "Language (Eltharin)",
    "Melee (Basic)",
    "Outdoor Survival",
    "Perception",
    "Ranged (Bow)",
    "Stealth (Rural)",
    "Track"
  ],
}

CONFIG.speciesTalents = {
  "human" : [
    "Doomed",
    "Savvy, Suave",
    3
  ],
  "dwarf" : [
    "Magic Resistance",
    "Night Vision",
    "Read/Write, Relentless",
    "Resolute, Strong-minded",
    "Sturdy",
    0
  ],
  "halfling" : [
    "Acute Sense (Taste)",
    "Night Vision",
    "Resistance (Chaos)",
    "Small",
    0
  ],
  "helf" : [
    "Acute Sense (Sight)",
    "Coolheaded, Savvy",
    "Night Vision",
    "Second Sight, Sixth Sense",
    "Read/Write",
    0
  ],
  "welf" : [
    "Acute Sense (Sight)",
    "Hardy, Second Sight",
    "Night Vision",
    "Second Sight, Sixth Sense",
    "Read/Write",
    0
  ],
}

CONFIG.speciesMovement = {
  "human" : 4,
  "dwarf" : 3,
  "halfling" : 3,
  "helf" : 5,
  "welf" : 5
}



// Status Tiers
CONFIG.statusTiers = {
  "g" : "Gold",
  "s" : "Silver",
  "b" : "Brass"
};

// Characteristic Names
CONFIG.characteristics = {
  "ws": "Weapon Skill",
  "bs": "Ballistic Skill",
  "s": "Strength",
  "t": "Toughness",
  "i": "Initiative",
  "ag": "Agility",
  "dex": "Dexterity",
  "int": "Intelligence",
  "wp": "Willpower",
  "fel": "Fellowship"
};

// Characteristic Abbreviations
CONFIG.characteristicsAbbrev = {
  "ws": "WS",
  "bs": "BS",
  "s": "S",
  "t": "T",
  "i": "I",
  "ag": "Ag",
  "dex": "Dex",
  "int": "Int",
  "wp": "WP",
  "fel": "Fel"
};

CONFIG.skillTypes = {
  "bsc" : "Basic",
  "adv" : "Advanced"
};

CONFIG.xpCost = {
  "characteristic" : [25, 30, 40, 50, 70, 90, 120, 150, 190, 230, 280, 330, 390, 450, 520],
  "skill" : [10, 15, 20, 30, 40, 60, 80, 110, 140, 180, 220, 270, 320, 380, 440]
}

CONFIG.skillGroup = {
  "isSpec" : "Is Specialization",
  "noSpec" : "Not Specialization"
};

CONFIG.talentMax = {
  "1":"1",
  "2":"2",
  "none":"None",
  "ws":" Weapon Skill Bonus",
  "bs":"Ballistic Skill Bonus",
  "s": "Strength Bonus",
  "t": "Toughness Bonus",
  "i": "Initiative Bonus",
  "ag": "Agility Bonus",
  "dex": "Dexterity Bonus",
  "int": "Intelligence Bonus",
  "wp": "Willpower Bonus",
  "fel": "Fellowship Bonus"
}


// Weapon Groups
CONFIG.weaponGroups = {
  "basic": "Basic",
  "cavalry": "Cavalry",
  "fencing": "Fencing",
  "brawling": "Brawling",
  "flail": "Flail",
  "parry": "Parry",
  "polearm": "Polearm",
  "twohanded": "Two-Handed",
  "blackpowder": "Blackpowder",
  "bow": "Bow",
  "crossbow": "Crossbow",
  "entangling": "Entangling",
  "engineering": "Engineering",
  "explosives": "Explosives",
  "sling": "Sling",
  "throwing": "Throwing",
};

// Given a group, what's the primary type, melee or ranged
CONFIG.groupToType = {
  "basic": "Melee",
  "cavalry": "Melee",
  "fencing": "Melee",
  "brawling": "Melee",
  "flail": "Melee",
  "parry": "Melee",
  "polearm": "Melee",
  "twohanded": "Melee",
  "blackpowder": "Ranged",
  "bow": "Ranged",
  "crossbow": "Ranged",
  "entangling": "Ranged",
  "engineering": "Ranged",
  "explosives": "Ranged",
  "sling": "Ranged",
  "throwing": "Ranged",
};

// Weapon Group Descriptions
CONFIG.weaponGroupDescriptions = {
  "basic": "Basic",
  "cavalry": "Cavalry weapons are assumed to be used when mounted. When not used from horse-back, all two-handed weapons in the Cavalry Weapon Group also count as Two-Handed weapons. Single-handed Cavalry weapons are not normally used when unmounted.",
  "fencing": "Fencing",
  "brawling": "Brawling",
  "flail": "Unskilled characters add the Dangerous Weapon Flaw to their Flails, and the other listed Weapon Qualities are not used.",
  "parry": "Any one-handed weapon with the Defensive Quality can be used with Melee (Parry). When using Melee (Parry), a weapon can be used to Oppose an incoming attack without the normal –20 oﬀhand penalty.",
  "polearm": "Polearm",
  "twohanded": "Two-Handed",
  "blackpowder": "Those with Ranged (Engineering) can use Blackpowder weapons without penalty. If you are using a Blackpowder, Engineering, or Explosive weapon, and roll a Fumble that is also an even number — 00, 88, and so on — your weapon Misfires, exploding in your hand. You take full Damage to your primary arm location using the units die as an effective SL for the hit, and your weapon is destroyed.",
  "bow": "Bow",
  "crossbow": "Crossbows weapons are relatively simple to use. You can attempt a Ranged (Crossbow) Test using your Ballistic Skill, but the weapon loses all Qualities whilst retaining its Flaws.",
  "entangling": "Entangling",
  "engineering": "All Engineering weapons can be used by characters with Ranged (Blackpowder), but the weapons lose all Weapon Qualities whilst retaining their ﬂaws. If you are using a Blackpowder, Engineering, or Explosive weapon, and roll a Fumble that is also an even number — 00, 88, and so on — your weapon Misfires, exploding in your hand. You take full Damage to your primary arm location using the units die as an effective SL for the hit, and your weapon is destroyed.",
  "explosives": "Those with Ranged (Engineering) can use Explosive weapons without penalty. If you are using a Blackpowder, Engineering, or Explosive weapon, and roll a Fumble that is also an even number — 00, 88, and so on — your weapon Misfires, exploding in your hand. You take full Damage to your primary arm location using the units die as an effective SL for the hit, and your weapon is destroyed.",
  "sling": "Sling",
  "throwing": "Thrown weapons are relatively simple to use. You can attempt a Ranged (Throwing) Test using your Ballistic Skill, but the weapon loses all Qualities whilst retaining its Flaws.",
};

// Weapon Reach
CONFIG.weaponReaches={
  "personal":"Personal",
  "vshort":"Very Short",
  "short":"Short",
  "average": "Average",
  "long":"Long",
  "vLong":"Very Long",
  "massive":"Massive",
 }

 // Weapon reach descriptions
 CONFIG.reachDescription={
  "personal":"Your legs and fists, perhaps your head, and anything attached to those.",
  "vshort":"Less than a foot in length.",
  "short":"Up to 2 feet in length.",
  "average": "Up to 3 feet long.",
  "long":"Up to 6 feet long.",
  "vLong":"Up to 10 feet in length; can Engage enemies up to 4 yards away, rather than just 2.",
  "massive":"Anything over 10 feet long; can Engage enemies up to 6 yards away, rather than just 2",
 }

// Ammo Groups
CONFIG.ammunitionGroups = {
  "BPandEng": "Blackpowder and Engineering",
  "bow": "Bow",
  "crossbow": "Crossbow",
  "sling": "Sling",
};

// Item Qualities
CONFIG.itemQualities ={
  "durable": "Durable",
  "fine": "Fine",
  "lightweight": "Lightweight",
  "practical": "Practical",
};

// Item Flaws
CONFIG.itemFlaws = {
  "ugly": "Ugly",
  "shoddy": "Shoddy",
  "unreliable": "Unreliable",
  "bulky": "Bulky",
}


// Weapon Qualities
CONFIG.weaponQualities = {
  "accurate": "Accurate",
  "blackpowder": "Blackpowder",
  "blast": "Blast",
  "damaging": "Damaging",
  "defensive": "Defensive",
  "entangle": "Entangle",
  "fast": "Fast",
  "hack": "Hack",
  "impact": "Impact",
  "impale": "Impale",
  "penetrating": "Penetrating",
  "pistol": "Pistol",
  "precise": "Precise",
  "pummel": "Pummel",
  "repeater": "Repeater",
  "shield": "Shield",
  "trapblade": "Trap Blade",
  "unbreakable": "Unbreakable",
  "wrap": "Wrap"
};

// Weapon Flaws
CONFIG.weaponFlaws = {
  "dangerous": "Dangerous",
  "imprecise": "Imprecise",
  "reload": "Reload",
  "slow": "Slow",
  "tiring": "Tiring",
  "undamaging": "Undamaging"
};


// Weapon Quality Descriptions (Used in dropdown info)
CONFIG.qualityDescriptions = {
  "accurate": "The weapon is accurate and easy to hit with. Gain a bonus of +10 to any Test when firing this weapon",
  "blackpowder": "The crack of gunfire followed by gouts of smoke and confusion can be terrifying. If you are targeted by a Blackpowder weapon, you must pass an Average (+20) Cool Test or take a Broken Condition, even if the shot misses.",
  "blast": "All Characters within (Rating) yards of the struck target point take SL+Weapon Damage, and suffer any Conditions the weapon inflicts.",
  "damaging": "A Damaging weapon can use the higher score from either the units die or the SL to determine the Damage caused from a successful hit. For example, if you roll 34 in your attack Test and the target number was 52 you can choose to use the SL, which in this case is 2, or the units die result, which is 4. An Undamaging weapon can never also be Damaging (Undamaging takes precedent).",
  "defensive": "Defensive weapons are designed to parry incoming attacks. If you are wielding such a weapon, gain a bonus of +1 SL to any Melee Test when you oppose an incoming attack.",
  "distract": "Distracting weapons can be used to drive an opponent back due to their dangerous or whip-like natures. Instead of causing Damage, a successful attack with a Distracting weapon can force an opponent back 1 yard per SL by which you win the Opposed Test.",
  "entangle": "Your weapon wraps around your opponents, entangling them. Any opponent successfully hit by your weapon gains the Entangled Condition with a Strength value equal to your Strength Characteristic. When Entangling an opponent, you cannot otherwise use the weapon to hit. You can end the Entangling whenever you wish.",
  "fast": "Fast weapons are designed to strike out with such speed that parrying is not an option, leaving an opponent skewered before they can react. A wielder of a Fast weapon can choose to attack with the Fast weapon outside of the normal Initiative sequence, either striking first, last, or somewhere in between as desired. Further, all Melee Tests to defend against Fast weapons suffer a penalty of –10 if your opponent is using a weapon without the Fast Quality; other Skills defend as normal. Two opponents with Fast weapons fight in Initiative order (relative to each other) as normal. A Fast weapon may never also be Slow (Slow takes precedent).",
  "hack": "Hacking weapons have heavy blades that can hack through armor with horrific ease. If you hit an opponent, you Damage a struck piece of armor or shield by 1 point as well as wounding the target.",
  "impact": "Some weapons are just huge or cause terrible damage due to their weight or design. On a successful hit, add the result of the units die of the attack roll to any Damage caused by an Impact weapon. An Undamaging weapon can never also have Impact (Undamaging takes precedent).",
  "impale": "Impale weapons can kill with a single clean blow. Impale weapons cause a Critical Hit on any number divisible by 10 (i.e.: 10, 20, 30, etc.) as well as on doubles (i.e.: 11, 22, 33) rolled equal or under an appropriate Test in combat. If the impale comes from a ranged weapon, the ammunition used has firmly lodged itself in the target’s body. Arrows and bolts require a successful Challenging (+0) Heal Test to remove — bullets require a surgeon (see the Surgery Talent in Chapter 4: Skills and Talents). You cannot heal 1 of your Wounds for each unremoved arrow or bullet.",
  "penetrating": "The weapon is highly effective at penetrating armour. Non-metal APs are ignored, and the first point of all other armour is ignored.",
  "pistol": "You can use this weapon to attack in Close Combat.",
  "precise": "The weapon is easy to get on target. Gain a bonus of +1 SL to any successful Test when attacking with this weapon.",
  "pummel": "Pummel weapons are especially good at battering foes into submission. If you score a Head hit with a Pummel weapon, attempt an Opposed Strength/ Endurance test against the struck opponent. If you win the test, your opponent gains a Stunned Condition.",
  "repeater": "Your weapon holds (Rating) shots, automatically reloading after each time you fire. When you use all your shots, you must fully reload the weapon using the normal rules.",
  "shield": "If you use this weapon to oppose an incoming attack, you count as having (Rating) Armour Points on all locations of your body. If your weapon has a Shield Rating of 2 or higher (so: Shield 2 or Shield 3), you may also Oppose incoming missile shots in your Line of Sight.",
  "trapblade": "Some weapons are designed to trap other weapons, and sometimes even break them. If you score a Critical when defending against an attack from a bladed weapon you can choose to trap it instead of causing a Critical Hit. If you choose to do this, enact an Opposed Strength Test, adding your SL from the previous Melee Test. If you succeed, your opponent drops the blade as it is yanked free. If you score an Astounding Success, you not only disarm your opponent, but the force of your maneuver breaks their blade unless it has the Unbreakable quality. If you fail the Test, your opponent frees the blade and may fight on as normal.",
  "unbreakable": "The weapon is exquisitely well-made or constructed from an especially strong material. Under almost all circumstances, this weapon will not break, corrode, or lose its edge.",
  "wrap": "Wrap weapons typically have long chains with weights at the end, making it very difficult to parry them effectively. Melee Tests opposing an attack from a Wrap weapon suffer a penalty of –1 SL, as parried strikes wrap over the top of shields, or around blades.",
  "flexible": "Flexible armor can be worn under a layer of non-Flexible armor if you wish. If you do so, you gain the benefit of both.",
  "impenetrable": "The armor is especially resilient, meaning most attacks simply cannot penetrate it. All Critical Wounds caused by an odd number to hit you, such as 11 or 33, are ignored.",
  "durable": "Laboriously crafted using strong materials, the item can take +Durable Damage points before it suﬀers any negatives and gains a saving throw of 9+ on a 1d10 roll against instant breakage from sources like Trap Blade. This Quality can be taken multiple times. Each time it is taken, the saving throw improves by 1 (e.g. From 9+ to 8+).",
  "fine": "Meticulously crafted to please the eye. This Quality is a sign of social status and can be taken multiple times. The higher the quality, the more impressive it seems.",
  "lightweight": "Cleverly crafted for ease of carrying. Reduce Encumbrance points by 1.",
  "practical": "Expertly crafted with utility in mind. A failed test using this item receives +1 SL. If the item is a piece of armor, any penalties for wearing it are reduced by one level (for example from -30 to -20).",
};

// Weapon Flaw Descriptions (used in dropdown info)
CONFIG.flawDescriptions = {
  "dangerous": "Some weapons are almost as likely to hurt you as your opponent. Any failed test including a 9 on either 10s or units die results in a Fumble.",
  "imprecise": "Imprecise weapons are difficult to bring to bear as they are unwieldy or hard to aim. Suffer a penalty of –1 SL when using the weapon to attack. An Imprecise Weapon can never be Precise (Imprecise takes precedent).",
  "reload": "The weapon is slow to reload. An unloaded weapon with this flaw requires an Extended Ranged Test for the appropriate Weapon Group scoring (Rating) SL to reload. If you are interrupted while reloading, you must start again from scratch.",
  "slow": "Slow weapons are unwieldy and heavy, making them difficult to use properly. Characters using Slow weapons always strike last in a Round, regardless of Initiative order. Further, opponents gain a bonus of +1 SL to any Test to defend against your attack",
  "tiring": "The weapon is fatiguing to use or difficult to bring to bear. You only gain the benefit of the Impact and Damaging Weapon Traits on a Turn you Charge.<br><br><b>Note:</b> This changes the Damage shown in the chat card:<br> 'Not Charging' | 'Charging' Damage.",
  "undamaging": "Some weapons are not very good at penetrating armour. All APs are doubled against Undamaging weapons. Further, you do not automatically inflict a minimum of 1 Wound on a successful hit in combat.",
  "partial": "The armor does not cover the entire hit location. An opponent that rolls an even number to hit, or rolls a Critical Hit, ignores the partial armor’s APs.",
  "weakpoints": "The armor has small weakpoints where a blade can slip in if your opponent is sufficiently skilled or lucky. If your opponent has a weapon with the Impale Quality and scores a Critical, the APs of your armor are ignored.",
  "ugly": "Crafted without any aesthetic awareness whatsoever, Ugly items attract negative attention, and related Fellowship Tests might even suﬀer a –10 penalty.",
  "shoddy": "Hastily crafted by an amateur or fraudster. The item breaks when used in any failed Test rolling a double. Similarly, Shoddy armor breaks if any Critical Hit is sustained to a Hit Location it protects.",
  "unreliable": "Crafted without attention to functionality, a failed test using this item receives –1 SL. Further, penalties for wearing Unreliable armor are doubled.",
  "bulky": "An awkward design crafted clumsily. Increase Encumbrance by +1 (small trinkets cannot normally have this ﬂaw). Bulky clothing and armor are Enc 1 even when worn, and Fatigue penalties for armor are doubled."
};

// Armor Qualities
CONFIG.armorQualities = {
  "flexible": "Flexible",
  "impenetrable": "Impenetrable",
};

// Armor Flaws
CONFIG.armorFlaws = {
  "partial": "Partial",
  "weakpoints": "Weakpoints",
};

// Equipment Types
CONFIG.armorTypes = {
  "softLeather": "Soft Leather",
  "boiledLeather": "Boiled Leather",
  "mail": "Mail",
  "plate": "Plate",
  "other": "Other"
};

// Range Test Modifiers
CONFIG.rangeModifiers={
  "Point Blank" : "Easy (+40)",
  "Short Range":"Average (+20)",
  "Normal" : "Challenging (+0)",
  "Long Range": "Difficult (-10)",
  "Extreme": "Very Hard (-30)",
 }

// Difficulty Modifiers
CONFIG.difficultyModifiers = {
 "veasy" : 60,
 "easy" : 40 ,
 "average":20,
 "challenging":0,
 "difficult": -10,
 "hard" : -20,
 "vhard": -30
}

// Difficulty Labels
CONFIG.difficultyLabels = {

 "veasy" :"Very Easy (+60)",
 "easy" :"Easy (+40)",
 "average":"Average (+20)",
 "challenging":"Challenging (+0)",
 "difficult":"Difficult (-10)",
 "hard" :"Hard (-20)",
 "vhard":"Very Hard (-30)"
}

CONFIG.locations = {
 "head": "Head",
 "body": "Body",
 "rArm": "Right Arm",
 "lArm": "Left Arm",
 "rLeg": "Right Leg",
 "lLeg": "Left Leg",
}



// Trapping Availability
 CONFIG.availability = {
   "None": "-",
   "common": "Common",
   "scarce": "Scarce",
   "rare": "Rare",
   "exotic": "Exotic",
 }


// Trapping Types
CONFIG.trappingTypes = {
  "clothingAccessories":"Clothing and Accessories",
  "foodAndDrink":"Food and Drink",
  "toolsAndKits":"Tools and Kits",
  "booksAndDocuments":"Books and Documents",
  "tradeTools":"Trade Tools and Workshops", //unused, makes more sense to use Tools and Kits
  "drugsPoisonsHerbsDraughts":"Drugs, Poisons, Herbs, and Draughts",
  "ingredient":"Ingredient",
  "misc":"Miscellaneous"
};

// These categories are used to label items in containers (Trapping tab)
CONFIG.trappingCategories = {
  "weapon" : "Weapons",
  "armour" : "Armour",
  "money" : "Money",
  "ammunition" : "Ammunition",
  "container" : "Container",
  "clothingAccessories":"Clothing and Accessories",
  "foodAndDrink":"Food and Drink",
  "toolsAndKits":"Tools and Kits",
  "booksAndDocuments":"Books and Documents",
  "tradeTools":"Trade Tools and Workshops", //unused, makes more sense to use Tools and Kits
  "drugsPoisonsHerbsDraughts":"Drugs, Poisons, Herbs, and Draughts",
  "ingredient":"Ingredient",
  "misc":"Miscellaneous"
};

// Creature Sizes
CONFIG.actorSizes = {
  "tiny": "Tiny",
  "ltl": "Little",
  "sml": "Small",
  "avg": "Average",
  "lrg": "Large",
  "enor": "Enormous",
  "mnst": "Monstrous"
};

// Condition Types
CONFIG.magicLores = {
  "petty": "Petty",
  "beasts": "Beasts",
  "death": "Death",
  "fire": "Fire",
  "heavens": "Heavens",
  "metal": "Metal",
  "life": "Life",
  "light": "Light",
  "shadow": "Shadow",
  "hedgecraft": "Hedgecraft",
  "witchcraft": "Witchcraft",
  "daemonology": "Daemonology",
  "necromancy": "Necromancy",
  "nurgle": "Nurgle",
  "slaanesh": "Slaanesh",
  "tzeentch": "Tzeentch",
};

// Given a Lore, what is the Wind
CONFIG.magicWind = {
  "petty": "None",
  "beasts": "Ghur",
  "death": "Shyish",
  "fire": "Aqshy",
  "heavens": "Azyr",
  "metal": "Chamon",
  "life": "Ghyran",
  "light": "Hysh",
  "shadow": "Ulgu",
  "hedgecraft": "None",
  "witchcraft": "None",
  "daemonology": "Dhar",
  "necromancy": "Dhar",
  "nurgle": "Dhar",
  "slaanesh": "Dhar",
  "tzeentch": "Dhar",
};

CONFIG.loreEffect = {
  "petty": "None",
  "beasts": "Whenever you successfully cast a spell from the Lore of Beasts, you may also gain the Fear (1) Creature Trait for the next 1d10 Rounds.",
  "death": "Targets afflicted by spells from the Lore of Death are drained of life, enervated, and listless. You may assign +1 Fatigued Condition to any living target aﬀected by a spell from this lore. A target may only ever have a single Fatigued Condition gained in this manner at any one time.",
  "fire": "You may inﬂict +1 Ablaze Condition on anyone targeted by spells from the Lore of Fire, unless they also possess the Arcane Magic (Fire) Talent. Every Ablaze condition within Willpower Bonus yards adds +10 to attempts to Channel or Cast with Aqshy. ",
  "heavens": "Spells causing Damage ignore Armour Points from metal armour, and will arc to all other targets within 2 yards, except those with the Arcane Magic (Heavens) Talent, inﬂicting hits with a Damage equal to your Willpower Bonus, handled like a magical missile.",
  "metal": "Spells inﬂicting Damage ignore Armor Points from metal armor, and inﬂict bonus Damage equal to the number of Armor Points of metal armor being worn on any Hit Location struck. So, if your spell hit an Arm location protected by 2 Armor Points of metal armor, it would cause an additional +2 Damage and ignore the Armor Points.",
  "life": "Receive a +10 bonus to Casting and Channeling rolls when in a rural or wilderness environment. Living creatures — e.g. those without the Daemonic or Undead Creature Traits — targeted by Arcane Spells from the Lore of Life have all Fatigued and Bleeding Conditions removed after any other eﬀects have been applied as life magic ﬂoods through them. Creatures with the Undead Creature Trait, on the other hand, suﬀer additional Damage equal to your Willpower Bonus, ignoring Toughness Bonus and Armor Points, if aﬀected by any spell cast with the Lore of Life.",
  "light": "You may inﬂict one Blinded Condition on those targeted by Lore of Light spells, unless they possess the Arcane Magic (Light) Talent. If a target has the Daemonic or Undead Creature Traits, spells also inﬂict an additional hit with Damage equal to your Intelligence Bonus that ignores Toughness Bonus and Armor Points.",
  "shadow": "All spells cast from the Lore of Shadows inﬂicting Damage ignore all non-magical Armor Points.",
  "hedgecraft": "Hedgecraft spells cannot be cast without ingredients, which are an integral part of their spellcasting process.<br><br>Fortunately, the ingredients they use are easily found on the fringes of settlements and are usually herbs or plants. You receive 1 + SL ingredients on a successful foraging roll, using Lore (Herbs), as described under Gathering Food and Herbs, or you can buy them for 5 brass pennies each.",
  "witchcraft": "Each time practitioners of Witchcraft roll on a Miscast table, they also gain 1 Corruption point. Further, you may inﬂict one Bleeding Condition on anyone targeted by spells from the Lore of Witchcraft. Lastly, channeling or casting spells from this Lore automatically require a roll on the Minor Miscast table unless cast with an ingredient, where the ingredient provides no further protection should you roll a Miscast. Fortunately, ingredients for the Lore of Witchcraft are cheap and readily available: body parts of small animals for the most part. Ingredients cost a spell’s CN in brass pennies, instead of silver shillings, to purchase. Alternatively, a Witch may forage for parts, using the Outdoor Survival skill: a successful foraging roll receives 1 + SL ingredients, as described under Gathering Food and Herbs",
  "daemonology": "",
  "necromancy": "",
  "nurgle": "",
  "slaanesh": "",
  "tzeentch": "",
};

// Types of prayers
CONFIG.prayerTypes = {
  "blessing" : "Blessing",
  "miracle" : "Miracle"
}

CONFIG.mutationTypes = {
  "physical" : "Physical",
  "mental" : "Mental"
}

CONFIG.encumbrancePenalties = {
"encumbered" : "–1 Movement (min: 3), –10 Agility, +1 Travel Fatigue",
"veryEncumbered" : "–2 Movement (min: 2), –20 Agility (min: 10), +2 Travel Fatigue",
"maxEncumbered" : "You're not moving.",
}

CONFIG.conditions = {
  "ablaze" : "Ablaze",
  "bleeding" : "Bleeding",
  "blinded" : "Blinded",
  "broken" : "Broken",
  "deafened" : "Deafened",
  "entangled" : "Entangled",
  "fatigued" : "Fatigued",
  "poisoned" : "Poisoned",
  "prone" : "Prone",
  "stunned" : "Stunned",
  "surprised" : "Surprised",
  "unconscious" : "Unconscious"
}


CONFIG.conditionDescriptions = {
  "ablaze" : "At the end of every Round, you suﬀer 1d10 Wounds, modified by Toughness Bonus and Armor Points on the least protected Hit Location, with a minimum of 1 Wound suﬀered. Each extra Ablaze Condition you have adds +1 to the Damage suﬀered; so, three Ablaze Conditions result in 1d10+2 Damage suﬀered.<br><br>One Ablaze Condition can be removed with a successful Athletics Test, with each SL removing an extra Ablaze Condition. The Difficulty for this Test is modified by circumstances: it’s much easier to put out a fire rolling around on sand than it is in the middle of an oil-soaked kitchen",
  "bleeding" : "You are bleeding badly. Lose 1 Wound at the end of every Round, ignoring all modifiers. Further, suﬀer a penalty of –10 to any Tests to resist Festering Wounds, Minor Infection, or Blood Rot (see page 186). If you reach 0 Wounds, you no longer lose Wounds and instead fall immediately unconscious (gain the Unconscious Condition). At the end of Round, you have a 10% chance of dying per Bleeding Condition you have; so, if you had 3 Bleeding Conditions, you would die from blood loss on a roll of 0–30. If a double is scored on this roll, your wound clots a little: lose 1 Bleeding.You cannot regain consciousness until all Bleeding Conditions are removed (see Injury)<br><br>A Bleeding Condition can be removed with: a successful Heal Test, with each SL removing an extra Bleeding Condition; or with any spell or prayer that heals Wounds, with one Condition removed per Wound healed.<br><br>Once all Bleeding Conditions are removed, gain one Fatigued Condition.",
  "blinded" : "Perhaps because of a ﬂash of light, or because of liquid sprayed in your face, you are unable to see properly. You suﬀer a –10 penalty to all Tests involving sight, and any opponent attacking you in close combat gains a bonus of +10 to hit you.<br><br>One Blinded Condition is removed at the end of every other Round",
  "broken" : "You are terrified, defeated, panicked, or otherwise convinced you are going to die. On your turn, your Move and Action must be used to run away as fast as possible until you are in a good hiding place beyond the sight of any enemy; then you can use your Action on a Skill that allows you to hide more eﬀectively. You also receive a penalty of –10 to all Tests not involving running and hiding.<br><br>You cannot Test to rally from being Broken if you are Engaged with an enemy. If you are unengaged, at the end of each Round, you may attempt a Cool Test to remove a Broken Condition, with each SL removing an extra Broken Condition, and the Difficulty determined by the circumstances you currently find yourself: it is much easier to rally when hiding behind a barrel down an alleyway far from danger (Average +20) than it is when three steps from a slavering Daemon screaming for your blood (Very Hard –30).<br><br>If you spend a full Round in hiding out of line-of-sight of any enemy, you remove 1 Broken Condition.<br><br>Once all Broken Conditions are removed, gain 1 Fatigued Condition.",
  "deafened" : "Whether caused by a loud noise or a blow to the head, you are unable to hear properly. You suﬀer a –10 penalty to all Tests involving hearing, and any opponent attacking you in close combat from the ﬂank or rear gains an extra bonus of +10 to hit you (this bonus does not increase with multiple Deafened Conditions). One Deafened condition is removed at the end of every other Round and is often replaced with tinnitus.",
  "entangled" : "You are wrapped in something restricting your movement; it could be ropes, spider’s webbing, or an opponent’s bulging biceps. On your turn, you may not Move, and all your actions involving movement of any kind suﬀer a penalty of –10 (including Grappling). For your Action, you can remove an Entangled Condition if you win an Opposed Strength Test against the source of the entanglement, with each SL removing an extra Entangled Condition.",
  "fatigued" : "You are exhausted or stressed, and certainly in need of rest. You suﬀer a –10 penalty to all Tests. Removing a Fatigued Condition normally requires rest, a spell, or a divine eﬀect, though in some instances, such as when a Fatigued Condition is caused by carrying too much (see Encumbrance), simply changing your circumstances (carrying fewer trappings, for example) can remove a Condition.",
  "poisoned" : "You have been poisoned or injected with venom. All Tests to remove poison have their difficulty determined by the poison or venom suﬀered. At the end of each Round, lose 1 Wound, ignoring all modifiers. Also, suﬀer a penalty of –10 to all Tests.<br><br>If you reach 0 Wounds when Poisoned, you cannot heal any Wounds until all Poisoned conditions are removed. If you fall Unconscious when Poisoned, make an Endurance Test after a number of Rounds equal to your Toughness Bonus or die horribly. See Injury.<br><br>At the end of each Round, you may attempt an Endurance Test. If successful, remove a Poisoned Condition, with each SL removing an extra Poisoned Condition. A Heal Test provides the same results. Once all Poisoned Conditions are removed, gain 1 Fatigued Condition.",
  "prone" : "You have fallen to the ground, possibly because you have run out of Wounds, you’ve tripped, or because you’ve been hit by something rather large. On your turn, your Move can only be used to stand up or crawl at half your Movement in yards (note: if you have 0 Wounds remaining, you can only crawl). You suﬀer a –20 penalty to all Tests involving movement of any kind, and any opponent trying to strike you in Melee Combat gains +20 to hit you.<br><br>Unlike most other conditions, Prone does not stack — you are either Prone, or you are not. You lose the Prone Condition when you stand up.",
  "stunned" : "You have been struck about the head or otherwise disorientated or confused; your ears are likely ringing, and little makes sense.<br><br>You are incapable of taking an Action on your turn but are capable of half your normal movement. You can defend yourself in opposed Tests — but not with Language (Magick). You also suﬀer a –10 penalty to all Tests. If you have any Stunned Conditions, any opponent trying to strike you in Melee Combat gains +1 Advantage before rolling the attack.<br><br>At the end of each Round, you may attempt a Challenging (+0) Endurance Test. If successful, remove a Stunned Condition, with each SL removing an extra Stunned Condition.<br><br>Once all Stunned Conditions are removed, gain 1 Fatigued Condition if you don’t already have one.",
  "surprised" : "You have been caught unawares and you aren’t at all ready for what’s about to hit you. You can take no Action or Move on your turn and cannot defend yourself in opposed Tests. Any opponent trying to strike you in Melee Combat gains a bonus of +20 to hit.<br><br>The Surprised Condition does not stack, so you do not collect multiple Surprised Conditions, even should you be technically surprised multiple times in a Round.<br><br>At the end of each Round, or after the first attempt to attack you, you lose the Surprised Condition.",
  "unconscious" : "You are knocked out, asleep, or otherwise insensible. You can do nothing on your turn and are completely unaware of your surroundings. Any Melee attack targeting you automatically hits on the location of the attacker’s choice with the maximum possible SL it could score, and also inﬂicts a Critical Wound; or, if the GM prefers, any close combat hit simply kills you. Any ranged combat hit automatically does the same if the shooter is at Point Blank range.<br><br>The Unconscious Condition does not stack — you are either Unconscious, or you are not — so you do not collect multiple Unconscious Conditions.<br><br>Recovering from unconsciousness requires diﬀerent circumstances depending upon why you fell unconscious. Refer to Injury for more on this. If you spend a Resolve point to remove an Unconscious condition, but have not resolved the cause of the incapacitation, you gain another Unconscious Condition at the end of the round. When you lose the Unconscious Condition, you gain the Prone and Fatigued Conditions"
}

class DiceWFRP {
  /**
   * Prepare Test is called by the setup functions for the actors (see setupCharacteristic() for info on their usage)
   * The setup functions give 3 main objects to this function, which it expands with data used by all different
   * types of tests. It renders the dialog and creates the Roll object (rolled in the callback function, located
   * in the "setup" functions). It then calls renderRollCard() to post the results of the test to chat
   *
   * @param {Object} dialogOptions      Dialog template, buttons, everything associated with the dialog
   * @param {Object} testData           Test info: target number, SL bonus, success bonus, etc
   * @param {Object} cardOptions        Chat card template and info
   */
  static prepareTest({dialogOptions, testData, cardOptions, onClose}) {
    let rollMode = game.settings.get("core", "rollMode");

    // Merge input with generic properties constant between all tests
    mergeObject(testData,
    {
      testDifficulty : "challenging",
      testModifier : 0,
      slBonus : 0,
      successBonus : 0,
    });
    mergeObject(dialogOptions.data,
      {
        testDifficulty : "challenging",
        difficultyLabels : CONFIG.difficultyLabels,
        testModifier : dialogOptions.data.advantage * 10 || 0,
        slBonus : dialogOptions.data.slBonus || 0,
        successBonus : 0,
      });
    mergeObject(cardOptions,
      {
        user : game.user._id,
      })

    var roll;
    // If dialogOptions has a rollOverride, use it (spells, weapons, prayers)
    if (dialogOptions.rollOverride)
      roll = dialogOptions.rollOverride;
    else // Otherwise use a generic test
      roll = () =>{
      let roll = DiceWFRP.rollTest(testData);
      if (testData.extra)
        mergeObject(roll, testData.extra);
      DiceWFRP.renderRollCard(cardOptions, roll);
    }

    dialogOptions.data.rollMode = rollMode;
    dialogOptions.data.rollModes = CONFIG.rollModes;

    // Render Test Dialog
    renderTemplate(dialogOptions.template, dialogOptions.data).then(dlg => {
      new Dialog({
          title: dialogOptions.title,
          content: dlg,
          buttons: dialogOptions.buttons,
          close: html => dialogOptions.callback(html, roll)
        }).render(true);
    });
  }


  // Roll a standard Test and determine success
  static rollTest(testData){
    let roll = new Roll("1d100").roll();
    let successBonus = testData.successBonus;
    let slBonus = testData.slBonus;
    let targetNum = testData.target;
    let SL = (Math.floor(targetNum/10) - Math.floor(roll.total/10)) + slBonus;
    let description = "";


    // Test determination logic can be complicated due to SLBonus
    // SLBonus is always applied, but doesn't change a failure to a success or vice versa
    // Therefore, in this case, a positive SL can be a failure and a negative SL can be a success
    // Additionally, the auto-success/failure range can complicate things even more.

    // Failure
    if (roll.total >= 96 || roll.total > targetNum)
    {
      description = "Failure"
      if (roll.total >= 96 && SL > -1)
        SL = -1;

      switch(Math.abs(Number(SL)))
      {
        case 6:
          description = "Astounding " + description;
          break;

        case 5:
        case 4:
          description = "Impressive " + description;
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = "Marginal " + description;
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = "Astounding " + description;
      }
      if (SL > 0)
      {
        description = "Marginal Failure";
        SL = "+" + SL.toString();
      }
      if (SL == 0)
        SL = "-" + SL.toString()

    }
    // Success
    else if (roll.total <= 5 || roll.total <= targetNum)
    {
      description = "Success"
      if (game.settings.get("wfrp4e", "fastSL"))
      {
        let rollString = roll.total.toString();
        if (rollString.length == 2)
          SL = Number(rollString.split('')[0])
        else
          SL = 0;
      }
      SL += successBonus;
      if (roll.total <= 5 && SL < 1)
        SL = 1;

      switch(Math.abs(Number(SL)))
      {
        case 6:
          description = "Astounding " + description;
          break;

        case 5:
        case 4:
          description = "Impressive " + description;
          break;

        case 3:
        case 2:
          break;

        case 1:
        case 0:
          description = "Marginal " + description;
          break;

        default:
          if (Math.abs(Number(SL)) > 6)
            description = "Astounding " + description;
      }
      if (SL < 0)
        description = "Marginal Success";


      if (game.settings.get("wfrp4e", "testAbove100"))
      {
        if (targetNum > 100)
        {
          let addSL = Math.floor((targetNum - 100) / 10)
          SL += addSL;
        }
      }

      if (SL >= 0)
        SL = "+" + SL.toString()

    }

    let rollResults={
      target: targetNum,
      roll: roll.total,
      SL: SL,
      description: description,
      extra : {}
    }

    if (testData.hitLocation)
      rollResults.hitloc = WFRP_Tables.rollTable("hitloc");


      if (testData.hitLocation)
      {
        if (roll.total > targetNum && roll.total % 11 == 0 || roll.total == 100)
          rollResults.extra.fumble = "Fumble";
        else if (roll.total <= targetNum && roll.total % 11 == 0)
          rollResults.extra.critical = "Critical";
      }


    return rollResults;
   }

   // Extend rollTest to account for weapon specifics (criticals, fumbles, etc)
   static rollWeaponTest(testData){
    let weapon = testData.extra.weapon;

     let testResults = this.rollTest(testData);

     console.log(testResults.roll);

     if (testResults.description.includes("Failure"))
     {
       if (testResults.roll % 11 == 0 || testResults.roll == 100 || (weapon.properties.flaws.includes("Dangerous") && testResults.roll.toString().includes("9")))
       {
         testResults.extra.fumble = "Fumble"
         if ((weapon.data.weaponGroup.value == "Blackpowder" ||
             weapon.data.weaponGroup.value== "Engineering" ||
             weapon.data.weaponGroup.value== "Explosives") && testResults.roll % 2 == 0)
          {
          testResults.extra.misfire = "Misfire"
          testResults.extra.misfireDamage = eval(testResults.roll.toString().split('').pop() + weapon.data.damage.value)
          }
       }

       if (weapon.data.weaponGroup.value == "Throwing")
        testResults.extra.scatter = "Scatter";

     }
     else
     {
       if (testResults.roll % 11 == 0)
         testResults.extra.critical = "Critical"

       if (weapon.properties.qualities.includes("Impale") && testResults.roll % 10 == 0)
         testResults.extra.critical = "Critical"
     }
     return testResults;
  }

  // Extend rollTest for casting specifics (miscasts, CN, etc)
   static rollCastTest(testData){
    let spell = testData.extra.spell;
    let miscastCounter = 0;
    let testResults = this.rollTest(testData);

    if (game.settings.get("wfrp4e", "partialChannelling"))
    {
      spell.data.cn.value -= spell.data.cn.SL;
    }
    else if (spell.data.cn.SL >= spell.data.cn.value)
    {
      spell.data.cn.value = 0;
    }
    if (testData.extra.malignantInfluence)
      if (Number(testResults.roll.toString().split('').pop()) == 8)
        miscastCounter++;

    if (spell.data.lore.value == "witchcraft")
      miscastCounter++;

    let slOver = (Number(testResults.SL) - spell.data.cn.value)

    if (testResults.description.includes("Failure")) // Failed Test
    {
      testResults.description = "Casting Failed"
      if (testResults.roll % 11 == 0 || testResults.roll == 100)
        miscastCounter++;
    }
    else if (slOver < 0) // Successful test, but unable to cast
    {
      testResults.description = "Casting Failed"

      // TODO: If no ID
      if ((testResults.roll % 11 == 0)&& !testData.extra.ID)
      {
        testResults.description = "Casting Succeeded"
        testResults.extra.critical = "Critical Cast"
        miscastCounter++;
      }
    }
    else // Successful test, casted
    {
      testResults.description = "Casting Succeeded"
      let overcasts = Math.floor(slOver / 2);
      testResults.overcasts = overcasts;

      // If no ID
      if (testResults.roll % 11 == 0 && !testData.extra.ID)
        miscastCounter++;
    }

    switch (miscastCounter)
    {
      case 1:
        if (testData.extra.ingredient)
          testResults.extra.nullminormis = "Minor Miscast"
        else
          testResults.extra.minormis = "Minor Miscast"
      break;
      case 2:
          if (testData.extra.ingredient)
          {
            testResults.extra.nullmajormis = "Major Miscast"
            testResults.extra.minormis = "Minor Miscast"
          }
         else
           testResults.extra.majormis = "Major Miscast<"
           break;
      case 3:
      testResults.extra.majormis = "Major Miscast"
      break;
    }

    if (testData.extra.ingredient)
      miscastCounter--;
    if (miscastCounter < 0)
      miscastCounter = 0;
    if (miscastCounter > 2)
      miscastCounter = 2

    return testResults;
  }

  // Extend rollTest for channelling specifics (miscasts, CN, etc)
   static rollChannellTest(testData, actor){
    let spell = testData.extra.spell;
    let miscastCounter = 0;
     let testResults = this.rollTest(testData);
     let SL = testResults.SL;

     if (testData.extra.malignantInfluence)
       if (Number(testResults.roll.toString().split('').pop()) == 8)
         miscastCounter++;

      if (spell.data.lore.value == "witchcraft")
        miscastCounter++;

      if (testResults.description.includes("Failure")) // Failed Test
      {
        // Optional Rule: If SL in extended test is -/+0, counts as -/+1
        if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
          SL = -1;

       testResults.description = "Channell Failed"
       if (testResults.roll % 11 == 0 || testResults.roll % 10 == 0 || testResults.roll == 100)
         miscastCounter += 2;
      }
     else
     {
       testResults.description = "Channell Succeeded"

        // Optional Rule: If SL in extended test is -/+0, counts as -/+1
       if (Number(SL) == 0 && game.settings.get("wfrp4e", "extendedTests"))
        SL = 1;

        if (testResults.roll % 11 == 0 && !testData.extra.AA)
       {
         miscastCounter++;
         spell.data.cn.SL = spell.data.cn.value;
         testResults.extra.criticalchannell = "Critical Channell"

       }
     }

     // Add SL to CN and update actor
     spell.data.cn.SL += Number(SL);
     if (spell.data.cn.SL > spell.data.cn.value)
      spell.data.cn.SL = spell.data.cn.value;
    else if (spell.data.cn.SL < 0)
     spell.data.cn.SL = 0;
     actor.updateOwnedItem({id: spell.id , 'data.cn.SL' : spell.data.cn.SL});

     switch (miscastCounter)
     {
       case 1:
         if (testData.extra.ingredient)
           testResults.extra.nullminormis = "Minor Miscast"
         else
           testResults.extra.minormis = "Minor Miscast"
       break;
       case 2:
           if (testData.extra.ingredient)
           {
             testResults.extra.nullmajormis = "Major Miscast"
             testResults.extra.minormis = "Minor Miscast"
           }
          else
            testResults.extra.majormis = "Major Miscast"
            break;
       case 3:
          testResults.extra.majormis = "Major Miscast"
       break;
     }

     if (testData.extra.ingredient)
       miscastCounter--;
     if (miscastCounter < 0)
       miscastCounter = 0;
     if (miscastCounter > 2)
       miscastCounter = 2
     return testResults;
 }

  // Extend rollTest for pray specifics (sin, wrath of the gods, etc)
 static rollPrayTest(testData, actor){
  let prayer = testData.extra.prayer;
   let testResults = this.rollTest(testData);
   let SL = testResults.SL;
  let extensions = 0;
  let currentSin = actor.data.data.status.sin.value;
  testData.extra.sin = currentSin;


   if (testResults.description.includes("Failure"))
   {
     testResults.description = "Prayer Refused"
     let unitResult = Number(testResults.roll.toString().split('').pop())
     if (unitResult == 0)
      unitResult = 10;
     if (testResults.roll % 11 == 0 || unitResult <= currentSin)
       {
         testResults.extra.wrath = "Wrath of the Gods"
         currentSin--;
         if (currentSin < 0)
         currentSin = 0;
        actor.update({"data.status.sin.value" : currentSin});
        }

   }
   else
   {
     testResults.description = "Prayer Granted"
     let unitResult = Number(testResults.roll.toString().split('').pop())
     if (unitResult == 0)
      unitResult = 10;
     if (unitResult <= currentSin)
     {
       testResults.extra.wrath = "Wrath of the Gods"
       currentSin--;
       if (currentSin < 0)
       currentSin = 0;
      actor.update({"data.status.sin.value" : currentSin});
     }
    extensions = Math.floor(SL/2);
   }



   testResults.extensions = extensions;
   return testResults;
}

/** Take roll data and display it in a chat card template
* @param {Object} chatOptions - Object concerning display of the card like the template or which actor is testing
* @param {Object} testData - Test results, values to display, etc.
*/
 static renderRollCard(chatOptions, testData) {
   let chatData = {
     title : chatOptions.title,
     testData : testData
   }

   if ( ["gmroll", "blindroll"].includes(chatOptions.rollMode) ) chatOptions["whisper"] = ChatMessage.getWhisperIDs("GM");
   if ( chatOptions.rollMode === "blindroll" ) chatOptions["blind"] = true;

  // Generate HTML from the requested chat template
  return renderTemplate(chatOptions.template, chatData).then(html => {

    // Emit the HTML as a chat message
    chatOptions["content"] = html;
    chatOptions["type"] = 0;
    ChatMessage.create(chatOptions, false);
    return html;
  });
}



  // To be used in the future for opposed tests
  // static opposeData  = {
  //   opposeStarted : false,
  //   actor : undefined,
  //   rollData : undefined
  // }
  static chatListeners(html) {


    html.on("click", ".condition-chat", ev => {
      let cond = ev.target.text;
      cond = cond.split(" ")[0]
      let condkey = WFRP_Utility.findKey(cond, CONFIG.conditions);
      let condDescr = CONFIG.conditionDescriptions[condkey];
      let messageContent = `<b>${cond}</b><br>${condDescr}`

      let chatOptions = {user : game.user._id, rollMode : game.settings.get("core", "rollMode"), content : messageContent};
      if ( ["gmroll", "blindroll"].includes(chatOptions.rollMode) ) chatOptions["whisper"] = ChatMessage.getWhisperIDs("GM");
      if ( chatOptions.rollMode === "blindroll" ) chatOptions["blind"] = true;
      chatOptions["type"] = 0;
      ChatMessage.create(chatOptions);
    })


    html.on('mousedown', '.table-click', ev => {
      ev.preventDefault();
      let sin = Number($(ev.currentTarget).attr("data-sin"));
      let modifier = sin * 10 || 0;
      let html;
      let messageId = $(ev.currentTarget).parents('.message').attr("data-message-id");
      let senderId = game.messages.get(messageId).user._id;
      let chatOptions = {user : senderId, rollMode : game.settings.get("core", "rollMode")};


      if ( ["gmroll", "blindroll"].includes(chatOptions.rollMode) ) chatOptions["whisper"] = ChatMessage.getWhisperIDs("GM");
      if ( chatOptions.rollMode === "blindroll" ) chatOptions["blind"] = true;

      if (ev.button == 0)
      {
        if ($(ev.currentTarget).attr("data-table") == "misfire")
        {
          let damage = $(ev.currentTarget).attr("data-damage")
          html = "<b>Misfire</b>: Your weapon explodes! Take " + damage + " damage to your primary arm.";
        }
        else if (sin)
          html = WFRP_Tables.formatChatRoll($(ev.currentTarget).attr("data-table"), {modifier: modifier, maxSize: false});
        else
          html = WFRP_Tables.formatChatRoll($(ev.currentTarget).attr("data-table"), {modifier: modifier});

         chatOptions["content"] = html;
        chatOptions["type"] = 0;
        ChatMessage.create(chatOptions);

      }
      else if (ev.button == 2)
      {
        renderTemplate('public/systems/wfrp4e/templates/chat/table-dialog.html').then(html => {
          new Dialog({
            title: "Table Modifier",
            content: html,
            buttons: {
              roll: {
                label: "Roll",
                callback: (html) => {
                  let tableModifier = html.find('[name="tableModifier"]').val();
                  let minOne = html.find('[name="minOne"]').is(':checked');
                  html = WFRP_Tables.formatChatRoll($(ev.currentTarget).attr("data-table"), {modifier: tableModifier, minOne : minOne});
                  chatOptions["content"] = html;
				  chatOptions["type"] = 0;
                  ChatMessage.create(chatOptions);
                }
              },
            },
            default: 'roll'
          }).render(true);
        })
      }



    })
    // Chat card actions
    html.on('click', '.card-buttons button', ev => {
      ev.preventDefault();

      // Extract card data
      let button = $(ev.currentTarget),
          messageId = button.parents('.message').attr("data-message-id"),
          senderId = game.messages.get(messageId).user._id;

      // Confirm roll permission
      if ( !game.user.isGM && ( game.user._id !== senderId )) return;

      // Extract action data
      let action = button.attr("data-action"),
          card = button.parents('.chat-card'),
          actor = game.actors.get(card.attr('data-actor-id'));
      let rollData = { target : Number(card.attr('roll-target')),
           SL : card.attr('roll-SL'),
          result : Number(card.attr('roll-result'))
      };

      if (!this.opposeData.opposeStarted)
      {
        this.opposeData.opposeStarted = true;
        this.opposeData.actor = actor;
        this.opposeData.rollData = rollData;
        let chatOptions = {
          user: senderId,
          speaker: {
            alias: actor.name
          },
          template: "public/systems/wfrp4e/templates/chat/characteristic-roll.html",
        };

        return renderTemplate(chatOptions.template, rollData).then(html =>{

        let index = game.messages.entities.findIndex(e => e.data._id === messageId);
        let m = game.messages.entities[index];
        m.update({content: html}, true).then(message => {
          ui.chat.updateMessage(message);});
        });
    }
    else
    {
      this.opposeData.opposeStarted = false;
      let result = {result:  DiceWFRP.evaluateOpposedTest(actor, rollData)};
      let chatOptions = {
        user: game.user._id,
        template: "public/systems/wfrp4e/templates/chat/opposed-result.html"
      }
      return renderTemplate(chatOptions.template, result).then(html => {
           // Emit the HTML as a chat message
           chatOptions["content"] = html;
           chatOptions["type"] = 0;
           ChatMessage.create(chatOptions, false);
           return html;
      });
    }
    });
    html.on("click", '.item-property', event => {
      event.preventDefault();

      let li = $(event.currentTarget).parents(".chat-card"),
          property = event.target.text,
          properties = mergeObject(WFRP_Utility.qualityList(), WFRP_Utility.flawList()),
          propertyDescr = Object.assign(duplicate(CONFIG.qualityDescriptions), CONFIG.flawDescriptions);
          let propertyKey;
          property = property.replace(/,/g, '').trim();

          propertyKey = WFRP_Utility.findKey(property.split(" ")[0], properties)

          let propertyDescription = `<b>${property}:</b><br>${propertyDescr[propertyKey]}`;
          propertyDescription = propertyDescription.replace("(Rating)", property.split(" ")[1])

      // Toggle summary

      ChatMessage.create({content : propertyDescription, user : game.user._id, type : 0});
    });
  }

  static evaluateOpposedTest(defender, defenderRollData)
  {
    let opposeResult = {};
    let attackerSL = parseInt(this.opposeData.rollData.SL);
    let defenderSL = parseInt(defenderRollData.SL);
    let differenceSL = 0;
    if (attackerSL >= defenderSL)
      {
        differenceSL = attackerSL - defenderSL;
        opposeResult.result = this.opposeData.actor.name + " won by " + differenceSL + " SL";
      }
      else
      {
        differenceSL = defenderSL - attackerSL;
        opposeResult.result = defender.name + " won by " + differenceSL + " SL";
      }
      return opposeResult;
  }
}



/**
 * Activate certain behaviors on FVTT ready hook
 */
Hooks.once("init", () => {
  // fetch ("fgdb.json").then (r => r.json()).then(async records => {
  //   var fgtable = records["tables"]["category"]["id-00001"];
  //   var newtable = {
  //     name : "General Critical Hits",
  //     die : "1d100",
  //     rows : ["-"]
  //   }

  //   for (var fgrow in fgtable["tablerows"])
  //   {
  //     fgrow = fgtable["tablerows"][fgrow];
  //     var from = fgrow.fromrange;
  //     var to = fgrow.torange;
  //     for (var i = from; i <= to; i++)
  //     {
  //       var rowObj = {
  //         wounds : fgrow.results["id-00002"].result,
  //         name : fgrow.results["id-00001"].result,
  //         description : fgrow.results["id-00003"].result,
  //       }
  //       newtable.rows.push(rowObj);
  //     }
  //   }
  //   console.log(JSON.stringify(newtable));
  // })

  // fetch("doomings.txt").then(r => r.text()).then(t => {
  //   let array = t.split("\n").map(function(item) {
  //     return item.substring(3);
  //   });
  //   let table = {rows: [undefined]};
  //   for (let i = 0; i < array.length; i++)
  //   {
  //     table.rows.push({description : array[i]})
  //   }
  //   console.log(JSON.stringify(table));
  // })
  game.socket.emit("getFiles", "systems/wfrp4e/tables", {}, resp => {
    try
    {
    if (resp.error)
      throw ""
    for (var file of resp.files)
    {
      try {
        if (!file.includes(".json"))
          throw "Not JSON file"
        let filename = file.substring(file.lastIndexOf("/")+1, file.indexOf(".json"));
        fetch(file).then(r=>r.json()).then(async records => {
          WFRP_Tables[filename] = records;
        })
      }
      catch(error) {
       console.error("Error reading " + file + ": " + error)
      }
    }
  }
  catch
  {
    // Do nothing
  }
  })

  WFRP_Tables.scatter = {
    die : "1d10",
    rows : [
      undefined,
      {
        name : "Top Left"
      },
      {
        name : "Top Middle"
      },
      {
        name : "Top Right"
      },
      {
        name : "Center Left"
      },
      {
        name : "Center Right"
      },
      {
        name : "Bottom Left"
      },
      {
        name : "Bottom Middle"
      },
      {
        name : "Bottom Right"
      },
      {
        name : "At your feet"
      },
      {
        name : "At the target's feet"
      },
    ]
  }

  WFRP_Tables.winds = {
    die : "1d10",
    rows : [
      undefined,
      {
        modifier : "-30"
      },
      {
        modifier : "-10"
      },
      {
        modifier : "-10"
      },
      {
        modifier : "0"
      },
      {
        modifier : "0"
      },
      {
        modifier : "0"
      },
      {
        modifier : "0"
      },
      {
        modifier : "+10"
      },
      {
        modifier : "+10"
      },
      {
        modifier : "+30"
      }
    ]
  }

  // IMPORT CODE FOR CAREERS
/* let counter = 0;
  fetch ("careers.json").then(r => r.json()).then(async records => {
    let careerData = {
      data : {}
    };

    for (let careerClass of records) {
      for (let careerGroup of careerClass.CareerPaths) {
        for (let careerTier of careerGroup.Tiers) {
          careerData.name = careerTier.Name;
          careerData.type = "career"
          careerData.data["class.value"] = careerClass.ClassName;
          careerData.data["careergroup.value"] = careerGroup.PathName;
          careerData.data["level.value"] = careerTier.Tier;

          try {
          careerData.data["status.tier"] = careerTier.StatusTier[0].toLowerCase();
          careerData.data["status.standing"] = careerTier.StatusStanding;
          }
          catch{
            careerData.data["status.tier"] = "";
            careerData.data["status.standing"] = 0;
          }
          careerData.data["characteristics"] = [];
          careerData.data["skills"] = [];
          careerData.data["talents"] = [];
          careerData.data["trappings"] = [];
          for (let careerChar of careerTier.CareerCharacteristics){
            let chCounter = 0;
            for (let ch in CONFIG.characteristics){
              if (chCounter == careerChar){
                careerData.data.characteristics.push(ch);
                break;
              }
              chCounter++;
            }
          }
          for (let skill of careerTier.CareerSkills)
            careerData.data.skills.push(skill);
          for (let talent of careerTier.CareerTalents)
            careerData.data.talents.push(talent);
          for (let trappings of careerTier.CareerTrappings)
            careerData.data.trappings.push(trappings);

          let folder = game.folders.entities.find(f => f.name == careerGroup.PathName)
          try {
          careerData.folder = folder.data._id;
          }
          catch{
            careerData.folder = undefined;
          }
          await Item.create(careerData, {displaySheet : false});
        }
    }
  }
  })*/

    // IMPORT CODE FOR TALENTS
 /* fetch ("talents.json").then(r => r.json()).then(async records => {
    let talentData = {
      data : {},
    };
    for (data of records)
{
      talentData.name = data.Name;
      talentData.type = "talent"
      for (let talentMax in CONFIG.talentMax)
        if (CONFIG.talentMax[talentMax] == data.Max)
          talentData.data['max.value'] = talentMax;
      talentData.data["tests.value"] = data.Tests;
      talentData.data["description.value"] = data.Description;
      let folder = game.data.folders.find(f => f.name == "Talents");
      talentData.folder = folder._id;
      await Item.create(talentData, {displaySheet : false});
    }
  })*/

      // IMPORT CODE FOR TRAITS
 /*fetch ("traits.json").then(r => r.json()).then(async records => {
    let traitData = {
      data : {},
    };
    for (data of records)
{
      traitData.name = data.Name;
      traitData.type = "trait"
      traitData.data["description.value"] = data.Description;
      let folder = game.data.folders.find(f => f.name == "Traits");
      traitData.folder = folder._id;
      await Item.create(traitData, {displaySheet : false});
    }
  })*/

  // Register initiative rule
  game.settings.register("wfrp4e", "initiativeRule", {
    name: "Initiative Rules",
    hint: "Configure which method is used to determine who acts first in combat.",
    scope: "world",
    config: true,
    default: "default",
    type: String,
    choices: {
      "default": "Default (Highest to Lowest Initative, Agility Tiebreaks)",
      "sl": "Roll an Initiative test, higher SL goes first",
      "d10Init": "Roll a d10 and add Initiative, higher goes first",
      "d10InitAgi": "Roll a d10, add Initiative Bonus and Agility Bonus, higher goes first"
    },
    onChange: rule => _setWfrp4eInitiative(rule)
  });
  _setWfrp4eInitiative(game.settings.get("wfrp4e", "initiativeRule"));


  function _setWfrp4eInitiative(initMethod)
  {
    let formula;
    switch (initMethod)
    {
      case "default":
      formula = "@characteristics.i.value + @characteristics.ag.value/100";
      break;

      case "sl":
      formula = "(floor(@characteristics.i.value / 10) - floor(1d100/10))"
      break;

      case "d10Init":
      formula = "1d10 + @characteristics.i.value"
      break;

      case "d10InitAgi":
      formula = "1d10 + @characteristics.i.bonus + @characteristics.ag.bonus"
      break;
    }

    let decimals = (initMethod == "default") ? 2 : 0;
    CONFIG.initiative = {
      formula: formula,
      decimals: decimals
    }
  }


   // Register Advantage cap
   game.settings.register("wfrp4e", "capAdvantageIB", {
     name: "Cap Advantage at IB",
     hint: "Sets the max value of Advantage as the character's Initiative Bonus",
     scope: "world",
     config: true,
     default: false,
     type: Boolean
   });

  // Register Fast SL rule
  game.settings.register("wfrp4e", "fastSL", {
    name: "Fast SL",
    hint: "Determine SL with the Fast SL optional rule as described on page 152",
    scope: "world",
    config: true,
    default: false,
    type: Boolean
  });

  // Register Tests above 100% Rule
  game.settings.register("wfrp4e", "testAbove100", {
    name: "Tests Above 100%",
    hint: "Use optional rule Tests Above 100% as described on p 151. A successful Test gains +1 SL for each full 10% a tested Characteristic or Skill exceeds 100%",
    scope: "world",
    config: true,
    default: false,
    type: Boolean
  });


    // Register Extended Tests
    game.settings.register("wfrp4e", "extendedTests", {
      name: "Extended Tests and 0 SL",
      hint: "Rolling a +/- 0 on Extended Tests (currently only Channelling) results in a +1/-1 respectively (p155).",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Defensive auto-fill
    game.settings.register("wfrp4e", "defensiveAutoFill", {
      name: "Defensive Auto Populate",
      hint: "Wielding Defensive weapons automatically fills 'SL Bonus' in roll dialogs for melee weapons. This only occurs if it is not the actor's turn.",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register NPC Species Randomization
    game.settings.register("wfrp4e", "npcSpeciesCharacteristics", {
      name: "Set Average NPC Characteristics",
      hint: "Entering a recognized species value for an NPC automatically sets their characteristics to the average value for the species",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

    // Register Partial Channelling
    game.settings.register("wfrp4e", "partialChannelling", {
      name: "Partial Channelling",
      hint: "A common house rule that improves the flexibility of Channelling. Instead of requiring the SL to reach the spell's CN, you can instead cast at anytime with the CN reduced by the SL gained so far.",
      scope: "world",
      config: true,
      default: false,
      type: Boolean
    });

    // Register Defensive auto-fill
    game.settings.register("wfrp4e", "statusOnTurnStart", {
      name: "Show Combatant Status on Turn Start",
      hint: "When a Combatant starts their turn, their status is shown (Conditions and Modifiers). This status message is identical to the one shown from right clicking the combatant.",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });


    // Register Partial Channelling
    game.settings.register("wfrp4e", "focusOnTurnStart", {
      name: "Focus on Turn Start",
      hint: "When advancing the combat tracker, focus on the token that's going next.",
      scope: "world",
      config: true,
      default: true,
      type: Boolean
    });

  // Pre-load templates
  loadTemplates([
    "public/systems/wfrp4e/templates/actors/actor-attributes.html",
    "public/systems/wfrp4e/templates/actors/actor-abilities.html",
    "public/systems/wfrp4e/templates/actors/actor-main.html",
    "public/systems/wfrp4e/templates/actors/actor-combat.html",
    "public/systems/wfrp4e/templates/actors/actor-biography.html",
    "public/systems/wfrp4e/templates/actors/actor-inventory.html",
    "public/systems/wfrp4e/templates/actors/actor-skills.html",
    "public/systems/wfrp4e/templates/actors/actor-magic.html",
    "public/systems/wfrp4e/templates/actors/actor-religion.html",
    "public/systems/wfrp4e/templates/actors/actor-talents.html",
    "public/systems/wfrp4e/templates/actors/actor-classes.html",
    "public/systems/wfrp4e/templates/actors/actor-notes.html",
    "public/systems/wfrp4e/templates/actors/npc-main.html",
    "public/systems/wfrp4e/templates/actors/npc-notes.html",
    "public/systems/wfrp4e/templates/actors/creature-main.html",
    "public/systems/wfrp4e/templates/actors/creature-notes.html",
    "public/systems/wfrp4e/templates/actors/creature-main.html",
    "public/systems/wfrp4e/templates/chat/dialog-constant.html",
    "public/systems/wfrp4e/templates/chat/test-card.html",
    "public/systems/wfrp4e/templates/items/item-header.html",
    "public/systems/wfrp4e/templates/items/item-description.html",
  ]);
});

Hooks.on("ready", async () => {


  let activeModules = game.settings.get("core", "moduleConfiguration");

  for (let m in activeModules)
  {
    let module;
    if (activeModules[m])
    {
      game.socket.emit("getFiles", `modules/${m}/tables`, {}, resp => {
        try
        {
        if (resp.error)
          throw ""
        for (var file of resp.files)
        {
          try {
            if (!file.includes(".json"))
              throw "Not JSON file"
            let filename = file.substring(file.lastIndexOf("/")+1, file.indexOf(".json"));

            fetch(file).then(r=>r.json()).then(async records => {
             WFRP_Tables[filename] = records;
            })
          }
          catch(error) {
           console.error("Error reading " + file + ": " + error)
          }
        }
      }
      catch
      {
        // Do nothing
      }
      })
    }
  }
})

/**
 * Activate certain behaviors on Canvas Initialization hook
 */
Hooks.on("canvasInit", async () => {

  // let pack = game.packs.find(p => p.collection == "wfrp4e.trappings")
  // let list = await pack.getIndex();
  // let pathList = [];
  // await game.socket.emit("getFiles", "systems/wfrp4e/icons/equipment", {}, async resp => {
  //   for (var folder of resp.dirs)
  //   {
  //     await game.socket.emit("getFiles", folder, {}, async respItems => {
  //       for (let file of respItems.files)
  //         pathList.push(file);
  //     })
  //   }
  // })
  // for (let item of list)
  // {
  //   let name = item.name.toLowerCase().trim().replace(/,/g, '').replace(/ /g, '-').replace("/", '-')

  //   let img = pathList.find(p =>p.includes(name));
  //   if (!img)
  //     console.log(name);
  //   await pack.updateEntity({"_id": item.id, "img" : img});
  // }
  // for (let item of list)
  // {
  //   let name = item.name.toLowerCase().trim().replace(/,/g, '').replace(/ /g, '-').replace(/ /g, '-')



  //   let img = pathList.find(p =>p.includes(name));
  //   if (!img)
  //     console.log(name);
  //   await pack.updateEntity({"_id": item.id, "img" : img});
  // }

  // for (let item of list)
  // {
  //   let name = item.name.toLowerCase().trim().replace(/,/g, '').replace(/ /g, '-').replace(/ /g, '-')


  //   let img = pathList.find(p =>p.includes(name));
  //   if (!img)
  //     console.log(name);
  //   await pack.updateEntity({"_id": item.id, "img" : img});
  // }

  //  let pack = game.packs.find(p => p.collection == "world.arcanecareers")
  //  let list = await pack.getIndex();
  //  for (let skill of list)
  //  {
  //   let item = await pack.getEntity(skill.id);
  //   item.data.data.skills[0] = item.data.data.skills[0].replace("Channeling", "Channelling");
  //   console.log(item);
  //   await pack.updateEntity(item.data);
  //  }

  // pack = game.packs.find(p => p.collection == "world.spells")
  // let list = await pack.getIndex();
  // let weapons = game.items.entities.filter(x => x.type == "spell");
  // for (let wep of weapons)
  // {
  //   await pack.createEntity(wep.data);
  // }

  /**
   * Double every other diagonal movement
   */
  SquareGrid.prototype.measureDistance = function(p0, p1) {
    let gs = canvas.dimensions.size,
        ray = new Ray(p0, p1),
        nx = Math.abs(Math.ceil(ray.dx / gs)),
        ny = Math.abs(Math.ceil(ray.dy / gs));

    // Get the number of straight and diagonal moves
    let nDiagonal = Math.min(nx, ny),
        nStraight = Math.abs(ny - nx);

    let nd10 = Math.floor(nDiagonal / 2);
    let spaces = (nd10 * 2) + (nDiagonal - nd10) + nStraight;
    return spaces * canvas.dimensions.distance;


  }
});

Hooks.on("chatMessage", (html, content, msg) => {
  content = content.toLowerCase();

  let rollMode = game.settings.get("core", "rollMode");
  if ( ["gmroll", "blindroll"].includes(rollMode) ) msg["whisper"] = ChatMessage.getWhisperIDs("GM");
  if ( rollMode === "blindroll" ) msg["blind"] = true;
  msg["type"] = 0;

  let command = content.split(" ").map(function(item) {
    return item.trim();
  })
  if (command[0] == "/table")
  {
    if (command.length == 1)
      msg.content = WFRP_Tables.formatChatRoll("menu")
    else
    {
      modifier = parseInt(command[2]);
      msg.content = WFRP_Tables.formatChatRoll(command[1], {modifier : modifier})
    }
	ChatMessage.create(msg);
	return false;
  }

  else if (command[0] == "/cond")
  {
    let conditionInput = command[1].toLowerCase();
    let condList = Object.keys(CONFIG.conditions);
    let match = [];
    for (let cond of condList)
    {
      let percentage = 0;
      let matchCounter = 0;
      for (let i = 0; i < cond.length; i++)
      {
        if (cond[i] == conditionInput[i])
        {
          matchCounter++;
        }
      }
      percentage = matchCounter / cond.length;
      match.push(percentage);
    }
    let maxIndex = match.indexOf(Math.max.apply(Math, match));
    let description = CONFIG.conditionDescriptions[condList[maxIndex]];
    let name = CONFIG.conditions[condList[maxIndex]];

    msg.content = `<b>${name}</b><br>${description}`
	ChatMessage.create(msg);
	return false;
  }

});

Hooks.on("renderChatMessage", async (html, content, msg) => {
    if (!html.alias)
      return

    let cardContent = msg.children(".message-header").html()

});

Hooks.on("getActorDirectoryEntryContext", async (html, options) => {
  options.push(
  {
    name : "Add Basic Skills",
    condition: true,
    icon: '<i class="fas fa-plus"></i>',
    callback: target => {
      const actor = game.actors.get(target.attr('data-entity-id'));
      actor.addBasicSkills();
    }

  })
})

/**
 * Extend the base Actor class to implement additional logic specialized for D&D5e.
 */
class ActorWfrp4e extends Actor {

  // Give new actor all Basic skills
  static async create(data, options) {
    if (data.items) // If the created actor has items (only applicable to duplicated actors) bypass the new actor creation logic
    {
      super.create(data, options);
      return
    }

    if (data.type == "character")
    {
      let id = 1;
      const pack = game.packs.find(p => p.collection == "wfrp4e.skills")
      let skills = [];
      await pack.getIndex().then(index => skills = index);
      data.items = [];
      for (let sk of skills)
      {
        let skillItem = undefined;
        await pack.getEntity(sk.id).then(skill => skillItem = skill);
        skillItem.data.id = id;
        id++;
        if (skillItem.data.data.advanced.value == "bsc" && skillItem.data.data.grouped.value == "noSpec")
          data.items.push(skillItem.data);
        else if (skillItem.data.data.advanced.value == "bsc")
        {
          let startParen = skillItem.data.name.indexOf("(")
          skillItem.data.name = skillItem.data.name.substring(0, startParen).trim();
          if (data.items.filter(x => x.name.includes(skillItem.data.name)).length <= 0)
            data.items.push(skillItem.data);
        }
      }
     // Default auto calculation to true
      data.flags =
      {
        autoCalcRun :  true,
        autoCalcWalk :  true,
        autoCalcWounds :  true,
        autoCalcCritW :  true,
        autoCalcCorruption :  true,
        autoCalcEnc :  true
      }

      const trappings = game.packs.find(p => p.collection == "wfrp4e.trappings")
      let trappingsIndex = [];
      await trappings.getIndex().then(index => trappingsIndex = index);

      let money = trappingsIndex.filter (t => t.name.toLowerCase() == "gold crown" || t.name.toLowerCase() == "silver shilling" || t.name.toLowerCase() == "brass penny")

      for (let m of money)
      {
        let moneyItem = await trappings.getEntity(m.id);
        moneyItem.data.id = id;
        id++;
        moneyItem.data.data.quantity.value = 0;
        data.items.push(moneyItem.data);
      }
      super.create(data, options);

    }

    else if (data.type == "npc" || data.type == "creature")
    {
      new Dialog({
        title: "Add Basic Skills",
        content: '<p>Add Basic Skills?</p>',
        buttons: {
          yes: {
            label: "Yes",
            callback: async dlg => {
              let id = 1;
              const pack = game.packs.find(p => p.collection == "wfrp4e.skills")
              let skills = [];
              await pack.getIndex().then(index => skills = index);
              data.items = [];
              for (let sk of skills)
              {
                let skillItem = undefined;
                await pack.getEntity(sk.id).then(skill => skillItem = skill);
                skillItem.data.id = id;
                id++;
                if (skillItem.data.data.advanced.value == "bsc" && skillItem.data.data.grouped.value == "noSpec")
                  data.items.push(skillItem.data);
                else if (skillItem.data.data.advanced.value == "bsc")
                {
                  let startParen = skillItem.data.name.indexOf("(")
                  skillItem.data.name = skillItem.data.name.substring(0, startParen).trim();
                  if (data.items.filter(x => x.name.includes(skillItem.data.name)).length <= 0)
                    data.items.push(skillItem.data);
                }
              }
              data.flags =
              {
                autoCalcRun :  true,
                autoCalcWalk :  true,
                autoCalcWounds :  true,
                autoCalcCritW :  true,
                autoCalcCorruption :  true,
                autoCalcEnc :  true
              }
              const trappings = game.packs.find(p => p.collection == "wfrp4e.trappings")
              let trappingsIndex = [];
              await trappings.getIndex().then(index => trappingsIndex = index);

              let money = trappingsIndex.filter (t => t.name.toLowerCase() == "gold crown" || t.name.toLowerCase() == "silver shilling" || t.name.toLowerCase() == "brass penny")

              for (let m of money)
              {
                let moneyItem = await trappings.getEntity(m.id);
                moneyItem.data.id = id;
                id++;
                moneyItem.data.data.quantity.value = 0;
                data.items.push(moneyItem.data);
              }
              super.create(data, options);
            }
          },
          no: {
            label: "No",
            callback: async dlg => {
              data.flags =
              {
                autoCalcRun :  true,
                autoCalcWalk :  true,
                autoCalcWounds :  true,
                autoCalcCritW :  true,
                autoCalcCorruption :  true,
                autoCalcEnc :  true
              }
              super.create(data, options);
            }
          },
        },
        default: 'yes'
      }).render(true);
    }
    else
    {
      data.flags =
      {
        autoCalcRun :  true,
        autoCalcWalk :  true,
        autoCalcWounds :  true,
        autoCalcCritW :  true,
        autoCalcCorruption :  true,
        autoCalcEnc :  true
      }
      super.create(data, options);
    }
  }
  // Calculate dynamic data like Characteristic totals and movemen values
  prepareData(actorData) {
    try {
    actorData = super.prepareData(actorData);
    const data = actorData.data;

    for (let ch of Object.values(data.characteristics))
    {
      ch.value = ch.initial + ch.advances;
      ch.bonus = Math.floor(ch.value / 10)
    }

    // Prepare Character data
    if ( actorData.type === "character" ) this._prepareCharacterData(data);
    else if ( actorData.type === "npc" ) this._prepareNPCData(data);

    if (actorData.flags.autoCalcWalk)
      data.details.move.walk = parseInt(data.details.move.value)* 2;
    if (actorData.flags.autoCalcRun)
      data.details.move.run = parseInt(data.details.move.value) * 4;

    if (actorData.flags.autoCalcEnc)
    {
     actorData.data.status.encumbrance.max = data.characteristics.t.bonus + data.characteristics.s.bonus;
    }

    if (game.settings.get("wfrp4e", "capAdvantageIB"))
      actorData.data.status.advantage.max = data.characteristics.i.bonus
    else
      actorData.data.status.advantage.max = 10;


    return actorData;
    }
    catch(error)
    {
      console.error("Something went wrong with preparing actor data: " + error)
      ui.notifications.error("Something went wrong with preparing actor data: " + error)
      if (error.includes("max"))
        this.actor.update({"data.encumbrance" : {max: 0, current: 0, type: "Number", label : "Encumbrance"}}) // Adds compatibility with alpha - TODO: Remove

    }

  }


  /**
   * Prepare Character type specific data
   */
  _prepareCharacterData(data) {

    data.details.experience.current = data.details.experience.total - data.details.experience.spent;

  }


  /**
   * Prepare NPC type specific data
   */
  _prepareNPCData(data) {

  }

  /* --------------------------------------------------------------------------------------------------------- */
  /* Rolls
  /*
  /* All "setup______" functions gather the data needed to roll a certain test. These are in 3 main objects.
  /* These 3 objects are then given to DiceWFRP.prepareTest(), see that function for its usage.
  /*
  /* The 3 Main objects:
  /* testData - Data associated with modifications to rolling the test itself, or results of the test.
  /*            Examples of this are whether hit locations are found, Weapon qualities that may cause
                criticals/fumbles more often or ingredients for spells that cancel miscasts.
     dialogOptions - Data for rendering the dialog that's important for a specific test type.
                     Example: when casting or channelling, there should be an option for Malignant
                     Influences, but only for those tests.
     cardOptions - Which card to use, the title of the card, the name of the actor, etc.
  /* --------------------------------------------------------------------------------------------------------- */


  /**
   * Setup a characteristic test.
   * Prompt the user for input on which variety of roll they want to do.
   * @param {String} characteristicId     The characteristic id (e.g. "ws")
   */
  setupCharacteristic(characteristicId) {
    let char = this.data.data.characteristics[characteristicId];
    let title = char.label + " Test";
    let testData = {
      target : char.value,
      hitLocation : false
    };

    // Default a WS or BS test to use hit locations
    if (characteristicId == "ws" || characteristicId == "bs")
    {
      testData.hitLocation = true;
    }

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/characteristic-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      // class: "red",
      data : {
        hitLocation : testData.hitLocation,
        talents : this.data.flags.talentTests,
        advantage : this.data.data.status.advantage.value || 0
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        testData.target = testData.target + testData.testModifier + testData.testDifficulty;
        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)
        roll();
        }
    };

    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/characteristic-card.html"
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions
    });
  }

  /* -------------------------------------------- */

  /**
   * Setup a Skill Test
   * @param skill {object}  The Skill Object owned by a character
   */
  setupSkill(skill) {
    let char = this.data.data.characteristics[skill.data.characteristic.value];
    let title = skill.name + " Test";
    let testData = {
      target : char.value + skill.data.advances.value,
      hitLocation : false
    };

    // Default hit location to true if WS, BS, Melee, or Ranged is tested
    if (skill.data.characteristic.value == "ws" ||
        skill.data.characteristic.value == "bs" ||
        skill.name.includes("Melee") ||
        skill.name.includes("Ranged"))
    {
      testData.hitLocation = true;
    }

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/skill-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      data : {
        hitLocation : testData.hitLocation,
        talents : this.data.flags.talentTests,
        characteristicList : CONFIG.characteristics,
        characteristicToUse : skill.data.characteristic.value,
        advantage : this.data.data.status.advantage.value || 0
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        let characteristicToUse = html.find('[name="characteristicToUse"]').val();
        testData.target = this.data.data.characteristics[characteristicToUse].value
                             + testData.testModifier
                             + testData.testDifficulty
                             + skill.data.advances.value;
        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)
        roll();
        }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/skill-card.html"
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

    /**
   * Roll a Weapon Test
   * @param weapon {Object}   Weapon being used
   * @param event {Object}    Event fired to initiate the roll
   */
  setupWeapon(weapon, event) {
    let skillCharList = [];
    let ammo;
    let slBonus = 0 // Used when wielding defensive weapons
    let title = "Weapon Test - " + weapon.name;
    if (event.attackType == "melee")
    {
      // If Melee, default to Weapon Skill, but check to see if the actor has the specific skill for the weapon
      skillCharList.push("Weapon Skill")
      for (let meleeSkill of this.data.flags.combatSkills)
        if (meleeSkill.name.toLowerCase().includes("melee"))
          skillCharList.push(meleeSkill.name);

      if (game.settings.get("wfrp4e", "defensiveAutoFill") && (game.combat && game.combat.data.round != 0 && game.combat.turns))
      {
        // Defensive is only automatically used if there is a current combat, AND it is not the character's turn

        try
        {
          let currentTurn = game.combat.turns.find(t => t.active)

          if (this.data.token.actorLink)
          {
            if (this.data.token != currentTurn.actor.data.token)
              slBonus = this.data.flags.defensive;
          }
          else
          {
            if (currentTurn.tokenId != this.token.id)
              slBonus = this.data.flags.defensive;
          }
        }
        catch
        {
          slBonus = 0;
        }
      }
    }


    if (event.attackType == "ranged")
    {
      // If Ranged, default to Ballistic Skill, but check to see if the actor has the specific skill for the weapon
      skillCharList.push("Ballistic Skill")
      if (weapon.data.weaponGroup.value != "throwing" && weapon.data.weaponGroup.value != "explosives" && weapon.data.weaponGroup.value != "entangling")
      {
        // Check to see if they have ammo
        ammo = this.items.find(i => i.id == weapon.data.currentAmmo.value);
        if (!ammo || weapon.data.currentAmmo.value == 0 || ammo.data.quantity.value == 0)
        {
          ui.notifications.error("No Ammo!")
          return
        }
      }
      else if (weapon.data.quantity.value == 0)
      {
        ui.notifications.error("No Ammo!")
        return;
      }
      else
      {
        ammo = weapon;
      }
      for (let rangedSkill of this.data.flags.combatSkills)
        if (rangedSkill.name.toLowerCase().includes("ranged"))
          skillCharList.push(rangedSkill.name);
    }
    let testData = {
      target : 0,
      hitLocation : true,
      extra : {
        weapon : weapon,
        ammo : ammo,
        attackType : event.attackType
      }
    };

    // Default the selection to the specific skill (so user doesn't have to change it to the better option every time)
    let defaultSelection = CONFIG.groupToType[weapon.data.weaponGroup.value] + " (" + CONFIG.weaponGroups[weapon.data.weaponGroup.value] + ")";

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/weapon-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      data : {
        hitLocation : testData.hitLocation,
        talents : this.data.flags.talentTests,
        skillCharList : skillCharList,
        slBonus : slBonus || 0,
        defaultSelection : skillCharList.indexOf(defaultSelection),
        advantage : this.data.data.status.advantage.value || 0
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        let skillSelected = skillCharList[Number(html.find('[name="skillSelected"]').val())];
        if (skillSelected == "Weapon Skill" || skillSelected == "Ballistic Skill")
        {
          // If using only a characteristic, delete all qualities, set target number to characteristic value + modifiers
          testData.extra.weapon = WFRP_Utility._prepareWeaponCombat(this.data, weapon)
          //testData.extra.weapon.properties.flaws = testData.extra.weapon.properties.flaws.join(", ")
          testData.extra.weapon.properties.qualities = [];

          if (testData.extra.weapon.data.weaponGroup.value == "Flail")
          {
            if (!testData.extra.weapon.properties.flaws.includes("Dangerous"))
              testData.extra.weapon.properties.flaws.push("Dangerous")
          }

          if (skillSelected == "Weapon Skill")
            testData.target = this.data.data.characteristics.ws.value
          else if (skillSelected == "Ballistic Skill")
            testData.target = this.data.data.characteristics.bs.value

          testData.target += testData.testModifier + testData.testDifficulty;
        }
        else
        {
          // If using the appropriate skill, set the target number to characteristic value + advances + modifiers
          let skillUsed = this.data.flags.combatSkills.find(x=> x.name.toLowerCase() == skillSelected.toLowerCase())
          testData.extra.weapon = WFRP_Utility._prepareWeaponCombat(this.data, weapon)
         //testData.extra.weapon.properties.flaws = testData.extra.weapon.properties.flaws.join (", ")
         //testData.extra.weapon.properties.qualities = testData.extra.weapon.properties.qualities.join (", ")

          testData.target = this.data.data.characteristics[skillUsed.data.characteristic.value].value
                                                                              + testData.testModifier
                                                                              + testData.testDifficulty
                                                                              + skillUsed.data.advances.value;
        }

        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();

        // Aggregate all talent bonuses selected and add that to successBonus
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)
        // Perform the d100 roll
        roll();

        // Reduce ammo if necessary
        if (ammo && skillSelected != "Weapon Skill" && weapon.data.weaponGroup != "entangling")
        {
          ammo.data.quantity.value--;
          this.updateOwnedItem({id: ammo.id, "data.quantity.value" : ammo.data.quantity.value });
        }
      },
      // Override the default test evaluation to use weaponTest specific function
      rollOverride : () => {
        let roll = DiceWFRP.rollWeaponTest(testData);

        let damageToUse = roll.SL;
        let unitValue = Number(roll.roll.toString().split("").pop())
        unitValue = unitValue == 0 ? 10 : unitValue; // If unit value == 0, use 10


        if (testData.extra.weapon.properties.qualities.includes("Damaging") && unitValue > Number(roll.SL))
          damageToUse = unitValue;

        if (testData.extra.attackType == "melee")
          testData.extra.damage = eval(testData.extra.weapon.data.damage.meleeValue + damageToUse);
        if (testData.extra.attackType == "ranged")
          testData.extra.damage = eval(testData.extra.weapon.data.damage.rangedValue + damageToUse);

        if (testData.extra.weapon.properties.qualities.includes("Impact"))
          testData.extra.damage += unitValue;

        if (testData.extra.weapon.properties.flaws.includes("Tiring") && (damageToUse != roll.SL || testData.extra.weapon.properties.qualities.includes("Impact")))
        {
          if (testData.extra.attackType == "melee")
            testData.extra.damage = `${eval(testData.extra.weapon.data.damage.meleeValue + roll.SL)} | ${testData.extra.damage}` ;
          if (testData.extra.attackType == "ranged")
            testData.extra.damage = `${eval(testData.extra.weapon.data.damage.rangedValue + roll.SL)} | ${testData.extra.damage}` ;
        }
        if (testData.extra)
          mergeObject(roll, testData.extra);
        DiceWFRP.renderRollCard(cardOptions, roll);
      }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/weapon-card.html",
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

  // Roll spell Dialog - choose between Casting or Channelling
  spellDialog(spell, options) {
    renderTemplate("public/systems/wfrp4e/templates/chat/cast-channel-dialog.html").then(dlg => {
      new Dialog({
        title: "Cast or Channell",
        content: dlg,
        buttons: {
          cast: {
            label: "Cast",
            callback: btn => {
              this.setupCast(spell, options);
            }
          },
          channell: {
            label: "Channell",
            callback: btn => {
              this.setupChannell(spell, options);
            }
          },
        },
        default: 'cast'
      }).render(true);
    })
  }

  /**
   * Setup a Cast Test
   * @param spell {Object}   Spell being cast
   */
  setupCast(spell) {
    let title = "Casting Test - " + spell.name;
    let castSkills = [{key : "int", name : "Intelligence"}]
    castSkills = castSkills.concat(this.items.filter(i => i.name.toLowerCase() == "language (magick)" && i.type == "skill"))
    let defaultSelection = castSkills.findIndex(i => i.name.toLowerCase() == "language (magick)")
    let instinctiveDiction = (this.data.flags.talentTests.findIndex(x=>x.talentName.toLowerCase() == "instinctive diction") > -1) // instinctive diction boolean

    let preparedSpell = WFRP_Utility._prepareSpellOrPrayer(this.data, spell);
    let testData = {
      target : 0,
      hitLocation : true,
      extra : {
        spell : preparedSpell,
        malignantInfluence : false,
        ingredient : false,
        ID : instinctiveDiction
      }
    };

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/spell-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        },
      },
      data : {
        hitLocation : testData.hitLocation,
        malignantInfluence : testData.malignantInfluence,
        talents : this.data.flags.talentTests,
        advantage : this.data.data.status.advantage.value || 0,
        defaultSelection : defaultSelection,
        castSkills : castSkills
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());

        let skillSelected = castSkills[Number(html.find('[name="skillSelected"]').val())];

        if (skillSelected.key != "int")
        {
          testData.target = this.data.data.characteristics[skillSelected.data.characteristic.value].value
          + skillSelected.data.advances.value
          + testData.testDifficulty
          + testData.testModifier;
        }
        else
        {
          testData.target = this.data.data.characteristics.int.value
          + testData.testDifficulty
          + testData.testModifier;
        }

        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        testData.extra.malignantInfluence = html.find('[name="malignantInfluence"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)



        // Find ingredient being used, if any
        let ing = this.items.find(i => i.id == testData.extra.spell.data.currentIng.value)

        if (!ing || ing.data.quantity.value <= 0)
          testData.extra.ingredient = false;
        else
        {
          // Decrease ingredient quantity
          testData.extra.ingredient = true;
          ing.data.quantity.value--;
          this.updateOwnedItem(ing);
        }
        roll();
        },
        // Override generic roll with cast specific roll
        rollOverride : () =>
        {
          let roll = DiceWFRP.rollCastTest(testData);
          if (testData.extra)
            mergeObject(roll, testData.extra);
          DiceWFRP.renderRollCard(cardOptions, roll);
          this.updateOwnedItem({id: spell.id, 'data.cn.SL' : 0});
          // Update spell to reflect SL from channelling resetting to 0
        }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/spell-card.html"
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

 /**
   * Setup a Channelling Test
   * @param spell {Object}   Spell being channelled
   */
  setupChannell(spell) {
    let title = "Channelling Test - " + spell.name;
    let channellSkills = [{key : "wp", name : "Willpower"}]
    channellSkills = channellSkills.concat(this.items.filter(i => i.name.toLowerCase().includes("channel") && i.type == "skill"))
    let spellLore = spell.data.lore.value;
    let defaultSelection = channellSkills.indexOf(channellSkills.find(x => x.name.includes(CONFIG.magicWind[spellLore])));
    if (spellLore == "witchcraft")
    {
      defaultSelection = channellSkills.indexOf(channellSkills.find(x => x.name.includes("Channelling")))
    }
    let aethyricAttunement = (this.data.flags.talentTests.find(x=>x.talentName.toLowerCase() == "aethyric attunement") > -1) // aethyric attunement boolean

    let testData = {
      target : 0,
      extra : {
        spell : WFRP_Utility._prepareSpellOrPrayer(this.data, spell),
        malignantInfluence : false,
        ingredient : false,
        AA : aethyricAttunement
      }
    };

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/channell-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      data : {
        malignantInfluence : testData.malignantInfluence,
        channellSkills : channellSkills,
        defaultSelection: defaultSelection,
        talents : this.data.flags.talentTests,
        advantage : "N/A"
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        testData.extra.malignantInfluence = html.find('[name="malignantInfluence"]').is(':checked');
        let skillSelected = channellSkills[Number(html.find('[name="skillSelected"]').val())];

        if (skillSelected.key != "wp")
        {
        testData.target = testData.testModifier + testData.testDifficulty
                         + this.data.data.characteristics[skillSelected.data.characteristic.value].value
                         + skillSelected.data.advances.value
        }
        else
          testData.target = testData.testModifier + testData.testDifficulty + this.data.data.characteristics.wp.value

        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)


        // Find ingredient being used, if any
        let ing = this.items.find(i => i.id == testData.extra.spell.data.currentIng.value)

        if (!ing || ing.data.quantity.value <= 0)
          testData.extra.ingredient = false;
        else
        {
          // Decrease ingredient quantity
          testData.extra.ingredient = true;
          ing.data.quantity.value--;
          this.updateOwnedItem(ing);
        }

        roll(this);
        },
        // Override generic roll with channell specific function
      rollOverride : (actor) => {
        let roll = DiceWFRP.rollChannellTest(testData, actor);
        if (testData.extra)
          mergeObject(roll, testData.extra);
        DiceWFRP.renderRollCard(cardOptions, roll);
      }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/channell-card.html"
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

   /**
   * Setup a Prayer Test
   * @param prayer {Object}   prayer being invoked
   */
  setupPrayer(prayer, options) {
    let title = "Prayer Test - " + prayer.name;
    let praySkills = [{key : "fel", name : "Fellowship"}]
    praySkills = praySkills.concat(this.items.filter(i => i.name.toLowerCase() == "pray" && i.type == "skill"));
    let defaultSelection = praySkills.findIndex(i => i.name.toLowerCase() == "pray")

    let preparedPrayer = WFRP_Utility._prepareSpellOrPrayer(this.data, prayer);
    let testData = {
      target : 0,
      hitLocation : true,
      extra : {
        prayer : preparedPrayer,
      }
    };

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/prayer-dialog.html",
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      data : {
        hitLocation : testData.hitLocation,
        talents : this.data.flags.talentTests,
        advantage : this.data.data.status.advantage.value || 0,
        praySkills : praySkills,
        defaultSelection : defaultSelection
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        let skillSelected = praySkills[Number(html.find('[name="skillSelected"]').val())];

        if (skillSelected.key != "fel")
        {
          testData.target = this.data.data.characteristics[skillSelected.data.characteristic.value].value
          + skillSelected.data.advances.value
          + testData.testDifficulty
          + testData.testModifier;
        }
        else
        {
          testData.target = this.data.data.characteristics.fel.value
          + testData.testDifficulty
          + testData.testModifier;
        }

        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)

        roll();
        },
        // Override generic test function with prayer specific function
      rollOverride : () => {
        let roll = DiceWFRP.rollPrayTest(testData, this);
        if (testData.extra)
          mergeObject(roll, testData.extra);
        DiceWFRP.renderRollCard(cardOptions, roll);
      }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/prayer-card.html"
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

  /**
   * Roll a test associated with a trait
   * @param prayer {Object}   Trait being tested
   */
  rollTrait(trait) {
    if (!trait.data.rollable.value)
      return;
    let char = this.data.data.characteristics[trait.data.rollable.rollCharacteristic];
    let title =   CONFIG.characteristics[trait.data.rollable.rollCharacteristic] + " Test - " + trait.name;
    let testData = {
      target : char.value,
      hitLocation : false
    };

    if (trait.data.rollable.rollCharacteristic == "ws" || trait.data.rollable.rollCharacteristic == "bs" )
      testData.hitLocation = true;

    let dialogOptions = {
      title: title,
      template : "/public/systems/wfrp4e/templates/chat/skill-dialog.html", // Reuse skill dialog
      buttons : {
        rollButton : {
          label: "Roll"
        }
      },
      data : {
        hitLocation : testData.hitLocation,
        talents : this.data.flags.talentTests,
        characteristicList : CONFIG.characteristics,
        characteristicToUse : trait.data.rollable.rollCharacteristic,
        advantage : this.data.data.status.advantage.value || 0
      },
      callback : (html, roll) => {
        cardOptions.rollMode = html.find('[name="rollMode"]').val();
        testData.testModifier = Number(html.find('[name="testModifier"]').val());
        testData.testDifficulty = CONFIG.difficultyModifiers[html.find('[name="testDifficulty"]').val()];
        testData.successBonus = Number(html.find('[name="successBonus"]').val());
        testData.slBonus = Number(html.find('[name="slBonus"]').val());
        let characteristicToUse = html.find('[name="characteristicToUse"]').val();
        testData.target = this.data.data.characteristics[characteristicToUse].value
                             + testData.testModifier
                             + testData.testDifficulty
        testData.hitLocation = html.find('[name="hitLocation"]').is(':checked');
        let talentBonuses = html.find('[name = "talentBonuses"]').val();
        testData.successBonus += talentBonuses.reduce(function (prev, cur){
          return prev + Number(cur)
        }, 0)
        roll();
        }
    };
    let cardOptions = {
      actor : this.data.id,
      speaker: {
        alias: this.data.name,
      },
      title: title,
      template : "public/systems/wfrp4e/templates/chat/skill-card.html" // Reuse skill card
    }
    // Call the roll helper utility
    DiceWFRP.prepareTest({
      dialogOptions : dialogOptions,
      testData : testData,
      cardOptions : cardOptions});
  }

  static getBonus(value) {
    return Math.floor(value / 10)
  }

  // Readds all Basic and ungrouped skills that aren't already owned
  async addBasicSkills() {
    let ownedBasicSkills = this.data.items.filter(i => i.type == "skill" && i.data.advanced.value == "bsc");
    const pack = game.packs.find(p => p.collection == "wfrp4e.skills")
    let skills = [];
    await pack.getIndex().then(index => skills = index);
    for (let sk of skills)
    {
      let skillItem = undefined;
      await pack.getEntity(sk.id).then(skill => skillItem = skill);
      if (skillItem.data.data.advanced.value == "bsc")
      {
        if (skillItem.data.data.grouped.value != "noSpec")
        {
          let startParen = skillItem.data.name.indexOf("(")
          skillItem.data.name = skillItem.data.name.substring(0, startParen).trim();
        }

        if (!ownedBasicSkills.find(s => skillItem.data.name.includes(s.name)))
        {
          await this.createOwnedItem(skillItem.data);
          ownedBasicSkills.push(skillItem.data);
        }
      }
    }
  }

}

// Assign the actor class to the CONFIG
CONFIG.Actor.entityClass = ActorWfrp4e;



/**
 * Override and extend the basic :class:`Item` implementation
 */
class ItemWfrp4e extends Item {


  static async create(data, options) {

    if (!data.img)
      data.img = "systems/wfrp4e/icons/blank.png";
    super.create(data, options);
  }
  // Expand data is used in most dropdown infos
  getExpandData(htmlOptions) {
    const data = this[`_${this.data.type}ExpandData`]();
    data.description.value = data.description.value || "";
    data.description.value = enrichHTML(data.description.value, htmlOptions);
    return data;
  }

  _trappingExpandData() {
    const data = duplicate(this.data.data);
    data.properties = [];
    return data;
  }

  _psychologyExpandData() {
    const data = duplicate(this.data.data);
    data.properties = [];
    return data;
  }

  _mutationExpandData() {
    const data = duplicate(this.data.data);
    data.properties = [];
    data.properties.push(CONFIG.mutationTypes[this.data.data.mutationType.value]);
    if (this.data.data.modifier.value)
      data.properties.push(this.data.data.modifier.value)
    return data;
  }

  _diseaseExpandData() {
    const data = duplicate(this.data.data);
    data.properties = [];
    return data;
  }

  _talentExpandData() {
    const data = duplicate(this.data.data);
    data.properties=[];
    return data;
  }

  _traitExpandData() {
    const data = duplicate(this.data.data);
    data.properties=[];
    return data;
  }

  _careerExpandData() {
    const data = duplicate(this.data.data);
    data.properties=[];
    data.properties.push("<b>Class</b>: " + this.data.data.class.value);
    data.properties.push("<b>Group</b>: " + this.data.data.careergroup.value);
    data.properties.push(CONFIG.statusTiers[this.data.data.status.tier] + " " + this.data.data.status.standing);
    data.properties.push("<b>Characteristics</b>: " + this.data.data.characteristics.map(i => i = " " + CONFIG.characteristicsAbbrev[i]));
    data.properties.push("<b>Skills</b>: " + this.data.data.skills.map(i => i = " " + i));
    data.properties.push("<b>Talents</b>: " + this.data.data.talents.map (i => i = " " + i));
    data.properties.push("<b>Income</b>: " + this.data.data.incomeSkill.map(i => " " + this.data.data.skills[i]));
    return data;
  }

  _injuryExpandData() {
    const data = duplicate(this.data.data);
    data.properties=[];
    return data;
  }

  _spellExpandData() {
    const data = duplicate(this.data.data);
    let preparedSpell = WFRP_Utility._prepareSpellOrPrayer(this.actor.data, duplicate(this.data));
    data.description = preparedSpell.data.description
    data.properties = [];
    data.properties.push("Range: " + preparedSpell.range);
    data.properties.push("Target: " + preparedSpell.target);
    data.properties.push("Duration: " + preparedSpell.duration);
    if (data.magicMissile.value)
      data.properties.push("Magic Missile: +" + preparedSpell.damage);
    else if (preparedSpell.data.damage.value)
      data.properties.push("Damage: +" + preparedSpell.damage);

    return data;
  }

   _prayerExpandData() {
    const data = duplicate(this.data.data);
    let preparedPrayer = WFRP_Utility._prepareSpellOrPrayer(this.actor.data, this.data);
    data.properties = [];
    data.properties.push("Range: " + preparedPrayer.range);
    data.properties.push("Target: " + preparedPrayer.target);
    data.properties.push("Duration: " + preparedPrayer.duration);
    if (preparedPrayer.data.damage.value)
      data.properties.push("Damage: " + preparedPrayer.data.damage.value);
    return data;
  }

  /* -------------------------------------------- */

  _weaponExpandData() {
   const data = duplicate(this.data.data);
    let properties = [];

    if (data.weaponGroup.value)
      properties.push(CONFIG.weaponGroups[data.weaponGroup.value]);
    if (data.range.value)
      properties.push("Range: " + data.range.value);
    if (data.damage.meleeValue)
      properties.push("Melee Damage: " + data.damage.meleeValue);
    if (data.damage.rangedValue)
      properties.push("Ranged Damage: " + data.damage.rangedValue);
    for (let prop of WFRP_Utility._prepareQualitiesFlaws(this.data))
      properties.push(prop);
    if (data.twohanded.value)
      properties.push("Two Handed");
    if (data.reach.value)
      properties.push ("Reach: " + CONFIG.weaponReaches[data.reach.value] + " - " + CONFIG.reachDescription[data.reach.value]);

    properties = properties.filter(p => p != "Special");
    if (data.special.value)
      properties.push ("Special: " + data.special.value);

    data.properties = properties.filter(p => !!p);
    return data;
  }

  _armourExpandData() {
    const data = duplicate(this.data.data);
     const properties = [];
     properties.push(CONFIG.armorTypes[data.armorType.value]);
     for (let prop of WFRP_Utility._prepareQualitiesFlaws(this.data))
       properties.push(prop);
     properties.push(data.penalty.value);

     data.properties = properties.filter(p => !!p);
     return data;
   }

   _ammunitionExpandData() {
    const data = duplicate(this.data.data);
     let properties = [];
     properties.push (CONFIG.ammunitionGroups[data.ammunitionType.value])

     if (data.range.value)
      properties.push("Range: " + data.range.value);

     if (data.damage.value)
      properties.push("Damage: " + data.damage.value);

     for (let prop of WFRP_Utility._prepareQualitiesFlaws(this.data))
       properties.push(prop);
     properties = properties.filter(p => p != "Special");
     if (data.special.value)
       properties.push ("Special: " + data.special.value);

     data.properties = properties.filter(p => !!p);
     return data;
   }

}
// Assign ItemWfrp4e class to CONFIG
CONFIG.Item.entityClass = ItemWfrp4e;


/**
 * Hook into chat log context menu
 */
Hooks.on("getChatLogEntryContext", (html, options) => {
});

/**
 * Override and extend the basic :class:`ItemSheet` implementation
 */
class ItemSheetWfrp4e extends ItemSheet {
  constructor(item, options) {
    super(item, options);
    this.mce = null;
  }

  /**
   * Use a type-specific template for each different item type
   */
  get template() {
    let type = this.item.type;
    return `public/systems/wfrp4e/templates/items/item-${type}-sheet.html`;
  }

  /* -------------------------------------------- */

  /**
   * Prepare item sheet data
   * Start with the base item data and extending with additional properties for rendering.
   */
  getData() {
    const data = super.getData();

    if (this.item.type === "skill")
    {
      data['characteristics'] = CONFIG.characteristics;
      data['skillGroup'] = CONFIG.skillGroup;
      data['skillTypes'] = CONFIG.skillTypes;
    }
    else if (this.item.type === "talent")
    {
      data['talentMaxs'] = CONFIG.talentMax;
    }
    else if (this.item.type == "weapon")
    {
      data['weaponGroups'] = CONFIG.weaponGroups;
      data['availability'] = CONFIG.availability;
      data['weaponReaches'] = CONFIG.weaponReaches
      data['ammunitionGroups'] = CONFIG.ammunitionGroups;
    }
    else if (this.item.type == "ammunition")
    {
      data['availability'] = CONFIG.availability;
      data['ammunitionGroups'] = CONFIG.ammunitionGroups;
    }
    else if (this.item.type == "armour")
    {
      data['armorTypes'] = CONFIG.armorTypes;
      data['availability'] = CONFIG.availability;
    }
    else if (this.item.type == "spell")
    {
      if (CONFIG.magicLores[this.item.data.data.lore.value])
      {
        data["loreValue"] = CONFIG.magicLores[this.item.data.data.lore.value]
      }
      else
      {
        data["loreValue"] = this.item.data.data.lore.value;
      }
      data["descriptionAndLore"] = WFRP_Utility._spellDescription(this.item.data)

    }
    else if (this.item.type == "prayer")
    {
      data['prayerTypes'] = CONFIG.prayerTypes;
    }


    else if (this.item.type == "career")
    {
      data['statusTiers'] = CONFIG.statusTiers;
      data['skills'] = data.data.skills.toString();
      data['earningSkills'] = data.data.incomeSkill.map(function(item) {
        return data.data.skills[item];
      });
      data['talents'] = data.data.talents.toString();
      data['trappings'] = data.data.trappings.toString();
      let characteristicList = duplicate(CONFIG.characteristicsAbbrev);
      for (let char in characteristicList)
      {
        if(data.data.characteristics.includes(char))
          characteristicList[char] = {abrev : CONFIG.characteristicsAbbrev[char], checked : true};
       else
        characteristicList[char] = {abrev : CONFIG.characteristicsAbbrev[char], checked : false};
      }
      data['characteristicList'] = characteristicList;

    }

    else if (this.item.type == "trapping")
    {
      data['trappingTypes'] = CONFIG.trappingTypes;
      data['availability'] = CONFIG.availability;
    }

    else if (this.item.type == "trait")
    {
      data['characteristics'] = CONFIG.characteristics;
    }

    else if (this.item.type == "container")
    {
      data['availability'] = CONFIG.availability;
    }

    else if (this.item.type == "mutation")
    {
      data['mutationTypes'] = CONFIG.mutationTypes;
    }


    return data;
  }

  /* -------------------------------------------- */

  /**
   * Activate listeners for interactive item sheet events
   */
  activateListeners(html) {
    super.activateListeners(html);


      // Activate tabs
    new Tabs(html.find(".tabs"), {
      initial: this.item.data.flags["_sheetTab"],
      callback: clicked => this.item.data.flags["_sheetTab"] = clicked.attr("data-tab")
    });

    // Checkbox changes
    html.find('input[type="checkbox"]').change(event => this._onSubmit(event));


    html.find('.lore-input').change(async event => {
      let inputLore = event.target.value;
      for (let lore in CONFIG.magicLores)
      {
        if (inputLore == CONFIG.magicLores[lore])
        {
          let folder = game.folders.entities.find(f => f.name == "Lore of " + CONFIG.magicLores[lore])

          await this.item.update({'data.lore.value' : lore});
         // await this.item.update({'img' : `systems/wfrp4e/icons/spells/${lore}.png`})
         // await this.item.update({"name" : this.item.data.name + " ("+CONFIG.magicLores[lore]+")"});
         // if (folder)
         //   await this.item.update({"folder" : folder.id})
          return;
        }
      }
      await this.item.update({'data.lore.value' : inputLore}); // If lore not recognized, save input as lore directly (custom lore)

    }),


    html.find('.char-checkbox').click(async event => {
      this._onSubmit(event);
      let charChanged = $(event.currentTarget).attr("name")

      let characteristicList = duplicate(this.item.data.data.characteristics);

      if (characteristicList.includes(charChanged))
        characteristicList.splice(characteristicList.findIndex(c => c == charChanged));
      else
        characteristicList.push(charChanged);

      if (this.item.actor)
        this.item.actor.updateOwnedItem({id: this.item.data.id, 'data.characteristics' : characteristicList})
      else
        await this.item.update({'data.characteristics' : characteristicList})

    }),

    html.find(".item-checkbox").click(async event => {
      this._onSubmit(event);
      let target = $(event.currentTarget).attr("data-target");
      let path = target.split(".");
      this.item.update({[`data.${target}`] : !this.item.data.data[path[0]][path[1]]})
    }),

    // This listener converts comma separated lists in the career section to arrays,
    // placing them in the correct location using update
    html.find('.csv-input').change(async event => {
        this._onSubmit(event);
        let list = event.target.value.split(",").map(function(item) {
        return item.trim();
      });

      switch(event.target.attributes["data-dest"].value)
      {
        case 'skills':
        {
          await this.item.update({id: this.item.data.id, 'data.skills': list});
        }
        break;

        // find the indices of the skills that match the earning skill input, send those
        // values to data.incomeSkill
        case 'earning':
        {
          this.item.update({'data.incomeSkill': []});
          let earningSkills = [];
          for (let sk in list){
            let skillIndex = this.item.data.data.skills.indexOf(list[Number(sk)])
            if (skillIndex == -1)
              continue;

            else
            {
              earningSkills.push(skillIndex);
            }

          }
          await this.item.update({'data.incomeSkill': earningSkills});
        }
        break;
        case 'talents':
        {
          await this.item.update({'data.talents': list});
        }
        break;

        case 'trappings':
        {
          await this.item.update({'data.trappings': list});
        }
        break;

      }
    });
  }
}

// Activate global listeners
Hooks.on('renderChatLog', (log, html, data) => DiceWFRP.chatListeners(html));

// Override CONFIG

try
{
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("wfrp4e", ItemSheetWfrp4e, {makeDefault: true});
}
catch // 0.3.4 and earlier compatibility
{
  CONFIG.Item.sheetClass = ItemSheetWfrp4e;
}

/**
 * Extend the basic ActorSheet class to do all the D&D5e things!
 * This sheet is an Abstract layer which is not used.
 */
class ActorSheetWfrp4e extends ActorSheet {


  /**
   * Return the type of the current Actor
   * @type {String}
   */
  get actorType() {
    return this.actor.data.type;
  }

    async _render(force = false, options = {}) {
      this._saveScrollPos();
      await super._render(force, options);
      this._setScrollPos();
    }

    // Add the class "save-scroll" to a div to save it's scroll position
   _saveScrollPos()
   {
      if (this.form === null)
        return;

      const html = $(this.form).parent();
      this.scrollPos = [];
     let lists = $(html.find(".save-scroll"));
     for (let list of lists)
     {
       this.scrollPos.push($(list).scrollTop());
     }
   }

    _setScrollPos()
    {
      if (this.scrollPos)
      {
        const html = $(this.form).parent();
        let lists = $(html.find(".save-scroll"));
        for (let i = 0; i < lists.length; i++)
        {
          $(lists[i]).scrollTop(this.scrollPos[i]);
        }
      }
    }

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  getData() {
    const sheetData = super.getData();
    this._prepareItems(sheetData.actor);

    let size;
    let trait = sheetData.actor.traits.find(t => t.name.toLowerCase().includes("size"));
    if (trait)
    {
      trait = this.actor.getOwnedItem(trait.id);
      size = trait.data.data.specification.value;
    }
    else
    {
      size = sheetData.actor.talents.find(x=>x.name.toLowerCase() == "small");
      if (size)
        size = size.name;
    }

    if (size)
    {
      for (let s in CONFIG.actorSizes)
      {
        if (CONFIG.actorSizes[s] == size)
          sheetData.actor.data.details.size.value = s;
      }
    }

    let hardyTrait = sheetData.actor.traits.find(t => t.name.toLowerCase().includes("hardy"))
    let hardyTalent = sheetData.actor.talents.find(t => t.name.toLowerCase().includes("hardy"))


    let tbMultiplier = (hardyTrait ? 1 : 0)
    if (hardyTalent)
      tbMultiplier += hardyTalent.data.advances.value || 0

    let sb = sheetData.actor.data.characteristics.s.bonus;
    let tb = sheetData.actor.data.characteristics.t.bonus;
    let wpb =sheetData.actor.data.characteristics.wp.bonus;

    if (sheetData.actor.flags.autoCalcCritW)
      sheetData.actor.data.status.criticalWounds.max = tb;

    let newWounds;


   if (sheetData.actor.flags.autoCalcWounds)
   {
     if (sheetData.actor.traits.find(t => t.name.toLowerCase().includes("construct")))
      wpb = sb;
    switch (sheetData.actor.data.details.size.value)
    {

      case "tiny":
      newWounds = 1 + tb * tbMultiplier;
      break;

      case "ltl":
      newWounds = tb + tb * tbMultiplier;
      break;

      case "sml":
      newWounds = 2 * tb + wpb + tb * tbMultiplier;
      break;

      case "avg":
      newWounds = sb + 2 * tb + wpb + tb * tbMultiplier;
      break;

      case "lrg":
      newWounds = 2 * (sb + 2 * tb + wpb + tb * tbMultiplier);
      break;

      case "enor":
      newWounds = 4 * (sb + 2 * tb + wpb + tb * tbMultiplier);
      break;

      case "mnst":
      newWounds = 8 * (sb + 2 * tb + wpb + tb * tbMultiplier);
      break;
    }

      if (sheetData.actor.data.status.wounds.max != newWounds)
      {
        this.actor.update({"data.status.wounds.max" : newWounds})
        this.actor.update({"data.status.wounds.value" : Number(newWounds)})

      }
    }

    if (sheetData.actor.flags.autoCalcRun)
    {
      if(sheetData.actor.traits.find(t => t.name.toLowerCase() == "stride"))
        sheetData.actor.data.details.move.run += sheetData.actor.data.details.move.walk;
    }

    if (sheetData.actor.flags.autoCalcEnc)
    {
      let strongBackTalent = sheetData.actor.talents.find(t => t.name.toLowerCase() == "strong back")
      let sturdyTalent = sheetData.actor.talents.find(t => t.name.toLowerCase() == "sturdy")

      if (strongBackTalent)
        sheetData.actor.data.status.encumbrance.max += strongBackTalent.data.advances.value;
      if (sturdyTalent)
        sheetData.actor.data.status.encumbrance.max += sturdyTalent.data.advances.value * 2;

    }



    sheetData.isToken = this.actor.token;
    sheetData.isGM = game.user.isGM;
    // Return data to the sheet
    return sheetData;
  }

  _prepareItems(actorData)
  {
      // These containers are for the various different tabs
      const careers = [];
      const basicSkills = [];
      const advancedOrGroupedSkills = [];
      const talents = [];
      const traits = [];
      const weapons = [];
      const armour = [];
      const AP = {
        head: 0,
        body: 0,
        rArm: 0,
        lArm: 0,
        rLeg: 0,
        lLeg: 0,
        shield: 0
      };
      const injuries = [];
      const grimoire = [];
      const petty = [];
      const blessings = [];
      const miracles = [];
      const psychology = [];
      const mutations = [];
      const diseases = [];
      let penalties = {
        "Armour" : {value : ""},
        "Injury" : {value : ""},
        "Mutation" : {value : ""},
      };

      // Inventory object is for the inventory tab
      const inventory = {
        weapons: { label: "Weapons", items: [], toggle: true, toggleName: "Equipped", show : false, dataType : "weapon" },
        armor: { label: "Armour", items: [], toggle: true, toggleName: "Worn", show : false, dataType : "armour"},
        ammunition: { label: "Ammunition", items: [], quantified: true, show : false, dataType : "ammunition"},
        clothingAccessories: { label: "Clothing and Accessories", items: [], toggle: true, toggleName: "Worn", show : false, dataType : "trapping" },
        booksAndDocuments: {label: "Books and Documents", items: [], show : false, dataType : "trapping"},
        toolsAndKits: {label: "Tools and Kits", items: [], show : false, dataType : "trapping"},
        foodAndDrink: {label: "Food and Drink", items: [], show : false, dataType : "trapping"},
        drugsPoisonsHerbsDraughts: {label: "Drugs, Herbs, Poisons, Draughts", items: [], quantified: true, show : false, dataType : "trapping"},
        misc: {label: "Miscellaneous", items: [], show : false, dataType : "trapping"}
      };
      const ingredients =  {label: "Ingredients", items: [], quantified: true, show: false, dataType : "trapping"};
      const money = {coins: [], total: 0, show : true};
      const containers = {items: [], show : false};
      const inContainers = [];

      // Money and ingredients are not in inventory object because they need more customization

      // Iterate through items, allocating to containers
      let totalEnc = 0;
      let hasSpells = false;
      let hasPrayers = false;
      let defensiveCounter = 0;

      for ( let i of actorData.items ) {
        try {
        i.img = i.img || DEFAULT_TOKEN;
        if (i.type === "talent")
        {
          WFRP_Utility._prepareTalent(actorData, i, talents);
        }

        else if ( i.type === "skill" )
        {
          WFRP_Utility._prepareSkill(actorData, basicSkills, advancedOrGroupedSkills, i);
        }


        else if (i.type === "ammunition")
        {
          i.encumbrance = Math.floor(i.data.encumbrance.value * i.data.quantity.value);
          if (i.data.location.value == 0){
            inventory.ammunition.items.push(i);
            inventory.ammunition.show = true
            totalEnc += i.encumbrance;
          }
          else{
            inContainers.push(i);
          }
        }

        else if (i.type === "weapon")
        {
          i.encumbrance = Math.floor(i.data.encumbrance.value * i.data.quantity.value);
          if (i.data.location.value == 0){
            i.toggleValue = i.data.equipped || false;
            inventory.weapons.items.push(i);
            inventory.weapons.show = true;
            totalEnc += i.encumbrance;
          }
          else {
            inContainers.push(i);
          }
          if (i.data.equipped)
          {
            weapons.push(WFRP_Utility._prepareWeaponCombat(actorData, i));
            let shieldProperty = i.properties.qualities.find(q => q.toLowerCase().includes("shield"))
            if (shieldProperty)
            {
               AP.shield += parseInt(shieldProperty.split(" ")[1]);
            }
            if (i.properties.qualities.find(q => q.toLowerCase().includes("defensive")))
            {
              defensiveCounter++;
            }
          }
        }

        else if (i.type === "armour")
        {

          i.encumbrance = Math.floor(i.data.encumbrance.value * i.data.quantity.value);
          if (i.data.location.value == 0){
            i.toggleValue = i.data.worn.value || false;
            if (i.data.worn.value)
            {
              i.encumbrance = i.encumbrance - 1;
              i.encumbrance = i.encumbrance < 0 ? 0 : i.encumbrance;
            }
            inventory.armor.items.push(i);
            inventory.armor.show = true;
            totalEnc += i.encumbrance;
          }
          else {
            inContainers.push(i);
          }

          if (i.data.worn.value)
            armour.push(WFRP_Utility._prepareArmorCombat(actorData, i, AP));
        }

        else if (i.type == "injury")
        {
          injuries.push(i);
          penalties["Injury"].value += i.data.penalty.value;
        }

        else if (i.type === "container")
        {
          i.encumbrance = i.data.encumbrance.value;

          if (i.data.location.value == 0){
          if (i.data.worn.value)
          {
            i.encumbrance = i.encumbrance - 1;
            i.encumbrance = i.encumbrance < 0 ? 0 : i.encumbrance;
          }
          totalEnc += i.encumbrance;
          }
          else{
            inContainers.push(i);
          }
          containers.items.push(i);
          containers.show = true;
        }

        else if (i.type === "trapping")
        {
          i.encumbrance = i.data.encumbrance.value * i.data.quantity.value;
          if (i.data.location.value == 0)
          {
            if (i.data.trappingType.value == "ingredient"){
              ingredients.items.push(i)
            }
            else if (i.data.trappingType.value == "clothingAccessories")
            {
              i.toggleValue = i.data.worn || false;
              inventory[i.data.trappingType.value].items.push(i);
              inventory[i.data.trappingType.value].show = true;
              if (i.data.worn)
              {
                i.encumbrance = i.encumbrance - 1;
                i.encumbrance = i.encumbrance < 0 ? 0 : i.encumbrance;
              }
            }
            else if (i.data.trappingType.value == "tradeTools")
            {
              inventory["toolsAndKits"].items.push(i)
              inventory["toolsAndKits"].show = true;
            }
            else if (i.data.trappingType.value)
            {
              inventory[i.data.trappingType.value].items.push(i);
              inventory[i.data.trappingType.value].show = true;
            }
            else
            {
              inventory.misc.items.push(i);
              inventory.misc.show = true;
            }
            totalEnc += i.encumbrance;
          }
          else{
            inContainers.push(i);
          }

        }


        else if (i.type === "spell")
        {
          hasSpells = true;
          if (i.data.lore.value == "petty")
            petty.push(WFRP_Utility._prepareSpellOrPrayer(actorData, i));
          else
            grimoire.push(WFRP_Utility._prepareSpellOrPrayer(actorData, i));
        }

        else if (i.type === "prayer")
        {
          hasPrayers = true;
          if (i.data.type.value == "blessing")
            blessings.push(WFRP_Utility._prepareSpellOrPrayer(actorData, i));
          else
            miracles.push(WFRP_Utility._prepareSpellOrPrayer(actorData, i));
        }

        else if (i.type === "career")
        {
          if (i.data.current.value)
          {
            actorData.currentClass = i.data.class.value;
            actorData.currentCareer = i.name;
            actorData.currentCareerGroup = i.data.careergroup.value;
            actorData.status = CONFIG.statusTiers[i.data.status.tier] + " " + i.data.status.standing;
            let availableCharacteristics = i.data.characteristics
            for (let char in actorData.data.characteristics)
            {
              if (availableCharacteristics.includes(char))
                actorData.data.characteristics[char].career = true;
            }
          }
          careers.push(i);
        }


        else if (i.type === "trait")
        {
          if (i.data.specification.value)
          {
            if (i.data.rollable.bonusCharacteristic)
            {
              i.data.specification.value = parseInt(i.data.specification.value) || 0
              i.data.specification.value += actorData.data.characteristics[i.data.rollable.bonusCharacteristic].bonus;
            }
            i.name = i.name + " (" + i.data.specification.value + ")";

          }
          traits.push(i);
        }


        else if (i.type === "psychology")
        {
          psychology.push(i);
        }

        else if (i.type === "disease")
        {
          i.data.incubation.roll = i.data.incubation.roll || i.data.incubation.value;
          i.data.duration.roll = i.data.duration.roll || i.data.duration.value;
          diseases.push(i);
        }

        else if (i.type === "mutation")
        {
          mutations.push(i);
          if (i.data.modifiesSkills.value)
            penalties["Mutation"].value += i.data.modifier.value;
        }

        else if (i.type === "money")
        {
          i.encumbrance = Math.floor(i.data.encumbrance.value * i.data.quantity.value);
          if (i.data.location.value == 0){
            money.coins.push(i);
            totalEnc += i.encumbrance;
          }
          else{
            inContainers.push(i);
          }
          money.total += i.data.quantity.value * i.data.coinValue.value;

        }
      }
      catch (error){
        console.error("Something went wrong with preparing item " + i.name + ": " + error)
        ui.notifications.error("Something went wrong with preparing item "+ i.name + ": " + error)
        ui.notifications.error("Deleting "+ i.name);
        this.actor.deleteOwnedItem(i.id, true);
      }
      }

      // If you have no spells, just put all ingredients in the miscellaneous section, otherwise, setup the ingredients to be available
      if (grimoire.length > 0 && ingredients.items.length > 0)
      {
        ingredients.show = true;
        actorData.ingredients = ingredients;
        for (let s of grimoire)
           s.data.ingredients = ingredients.items.filter(i => i.data.spellIngredient.value == s.id && i.data.quantity.value > 0)
      }
      else
        inventory.misc.items = inventory.misc.items.concat(ingredients.items);


      // Container Setup
      var containerMissing = inContainers.filter(i => containers.items.find(c => c.id == i.data.location.value) == undefined);
      for (var itemNoContainer of containerMissing) // Reset all items without container references (items that were removed from a contanier)
      {
        itemNoContainer.data.location.value = 0;
        this.actor.updateOwnedItem(itemNoContainer, true);;
      }
      for (var cont of containers.items) // For each container
      {
        // All items referencing (inside) that container
        var itemsInside = inContainers.filter(i => i.data.location.value == cont.id);
        itemsInside.map(function(item){ // Add category of item to be displayed
        if (item.type == "trapping")
          item.type = CONFIG.trappingCategories[item.data.trappingType.value];
        else
          item.type = CONFIG.trappingCategories[item.type];
      } )
        cont["carrying"] = itemsInside.filter(i => i.type != "Container");    // cont.carrying -> items the container is carrying
        cont["packsInside"] = itemsInside.filter(i => i.type == "Container"); // cont.packsInside -> containers the container is carrying
        cont["holding"] = itemsInside.reduce(function (prev, cur){            // cont.holding -> total encumbrance the container is holding
          return prev + cur.encumbrance;
        }, 0);
        cont.holding = Math.floor(cont.holding)
      }

      containers.items = containers.items.filter(c => c.data.location.value == 0); // Do not show containers inside other containers as top level (a location value of 0 means not inside a container)

      // talentTests is used to easily reference talent bonuses (e.g. in prepareTest function)
      // instead of iterating through every item again to find talents when rolling
      this.actor.data.flags.talentTests = [];
      for (let talent of talents)
        if (talent.data.tests.value)
          this.actor.data.flags.talentTests.push({talentName: talent.name, test : talent.data.tests.value, SL : talent.data.advances.value});
      this.actor.data.flags.combatSkills = [];
      for (let skill of basicSkills.concat(advancedOrGroupedSkills))
        if (skill.name.includes ("Melee") || skill.name.includes("Ranged"))
          this.actor.data.flags.combatSkills.push(skill);


      // Penalties box setup
      // If too much text, divide the penalties into groups
      let penaltiesOverflow = false;
      penalties["Armour"].value += WFRP_Utility._calculateArmorPenalties(actorData, armour);
      if ((penalties["Armour"].value + penalties["Mutation"].value + penalties["Injury"].value).length > 50)
      {
        penaltiesOverflow = true;
        for (let penaltyType in penalties)
        {
          if (penalties[penaltyType].value)
            penalties[penaltyType].show = true;
          else
            penalties[penaltyType].show = false;
        }
      }

      let penaltiesFlag = penalties["Armour"].value + " " + penalties["Mutation"].value + " " + penalties["Injury"].value + " " + this.actor.data.data.status.penalties.value
      penaltiesFlag = penaltiesFlag.trim();
      // This is for the penalty string in flags, for combat turn message
      if (this.actor.data.flags.modifier != penaltiesFlag && this.options.editable)
        this.actor.update({"flags.modifier" : penaltiesFlag})

      let armorTrait = traits.find(t => t.name.toLowerCase().includes("armour") || t.name.toLowerCase().includes("armor"))
      if (armorTrait)
      {
        for (let loc in AP)
        {
          try
          {
            if (loc != "shield")
              AP[loc] += parseInt(armorTrait.data.specification.value) || 0;
          }
          catch
          {
            //ignore armor traits with invalid values
          }
        }
      }

      this.actor.data.flags.defensive = defensiveCounter;





      let untrainedSkills = []
      let untrainedTalents = []
      let hasCurrentCareer = false;
      for (let career of careers)
      {
        if (career.data.current.value)
        {
          hasCurrentCareer = true;
          for (let sk of career.data.skills)
          {
            let trainedSkill = basicSkills.concat(advancedOrGroupedSkills).find(s => s.name.toLowerCase() == sk.toLowerCase())
            if (trainedSkill)
            {
              trainedSkill.career = true;
            }
            else
            {
              untrainedSkills.push(sk);
            }
          }

          for (let talent of career.data.talents)
          {
            let trainedTalents = talents.find(t => t.name == talent)
            if (trainedTalents)
            {
              trainedTalents.career = true;
            }
            else
            {
              untrainedTalents.push(talent);
            }
          }
        }
      }
      if (!hasCurrentCareer)
      {
        for (let char in actorData.data.characteristics)
          actorData.data.characteristics[char].career = false;
      }



      actorData.inventory = inventory;
      actorData.containers = containers;
      actorData.basicSkills = basicSkills.sort(WFRP_Utility.nameSorter);
      actorData.advancedOrGroupedSkills = advancedOrGroupedSkills.sort(WFRP_Utility.nameSorter);
      actorData.talents = talents;
      actorData.traits = traits;
      actorData.weapons = weapons;
      actorData.diseases = diseases;
      actorData.mutations = mutations;
      actorData.armour = armour;
      actorData.penalties = penalties;
      actorData.penaltyOverflow = penaltiesOverflow;
      actorData.AP = AP;
      actorData.injuries = injuries;
      actorData.grimoire = grimoire;
      actorData.petty = petty;
      actorData.careers = careers.reverse();
      actorData.blessings = blessings;
      actorData.miracles = miracles;
      actorData.money = money;
      actorData.psychology = psychology;
      actorData.flags.hasSpells = hasSpells;
      actorData.flags.hasPrayers = hasPrayers;
      actorData.untrainedSkills = untrainedSkills;
      actorData.untrainedTalents = untrainedTalents;

      let enc;
      try
      {
        enc = {
          max: actorData.data.status.encumbrance.max,
          value: Math.round(totalEnc * 10) / 10,
        };
      }
      catch
      {
        this.actor.data.flags.autoCalcEnc = true;
        this.actor.update({"data.status.encumbrance" : {max: 0, current: 0, type: "Number", label : "Encumbrance"}}) // Compatibility with alpha - TODO: Remove
        return
      }
      enc.pct = Math.min(enc.value * 100 / enc.max, 100);
      enc.state = enc.value / enc.max;
      if (enc.state > 3)
      {
        enc["maxEncumbered"] = true
        enc.penalty = CONFIG.encumbrancePenalties["maxEncumbered"];
      }
      else if (enc.state > 2)
        {
          enc["veryEncumbered"] = true
          enc.penalty = CONFIG.encumbrancePenalties["veryEncumbered"];
        }
      else if (enc.state > 1)
      {
        enc["encumbered"] = true
        enc.penalty = CONFIG.encumbrancePenalties["encumbered"];
      }
      else
        enc["notEncumbered"] = true;
      actorData.encumbrance = enc;
  }




  /* -------------------------------------------- */
  /*  Auto Advancement Functions
  /* -------------------------------------------- */
  async _advanceSpeciesSkills() {
    let skillList
    try
    {
      skillList = CONFIG.speciesSkills[this.actor.data.data.details.species.value];
      if (!skillList)
      {
        skillList = CONFIG.speciesSkills[WFRP_Utility.findKey(this.actor.data.data.details.species.value, CONFIG.species)]
        if (!skillList)
        {
          throw "Could not add skills for species " + this.actor.data.data.details.species.value;
        }
      }
    }
    catch(error)
    {
        ui.notifications.info("Could not find species " + this.actor.data.data.details.species.value)
        console.log("Could not find species " + this.actor.data.data.details.species.value + ": " + error);
        throw error
    }
    let skillSelector = new Roll(`1d${skillList.length}- 1`);
    skillSelector.roll().total;

    let skillsSelected = [];
    while (skillsSelected.length < 6)
    {
      skillSelector = skillSelector.reroll()
      if (!skillsSelected.includes(skillSelector.total))
        skillsSelected.push(skillSelector.total);
    }

    for (let skillIndex = 0; skillIndex < skillsSelected.length; skillIndex++)
    {
      if (skillIndex <= 2)
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 5)
      else
        await this._advanceSkill(skillList[skillsSelected[skillIndex]], 3)
    }
  }


  async _advanceSpeciesTalents() {
    let talentList
    try
    {
      talentList = CONFIG.speciesTalents[this.actor.data.data.details.species.value];
      if (!talentList)
      {
        talentList = CONFIG.speciesTalents[WFRP_Utility.findKey(this.actor.data.data.details.species.value, CONFIG.species)]
        if (!talentList)
          throw "Could not add talents for species " + this.actor.data.data.details.species.value;
      }
    }
    catch (error)
    {
      ui.notifications.info("Could not find species " + this.actor.data.data.details.species.value)
      console.log("Could not find species " + this.actor.data.data.details.species.value + ": " + error);
      throw error
    }
    let talentSelector;
    for (let talent of talentList)
    {
      if (!isNaN(talent)) // If is a number, roll on random talents
      {
        for (let i = 0; i < talent; i++)
        {
          let result = WFRP_Tables.rollTable("talents")
          await this._advanceTalent(result.name);
        }
        continue
      }
      let talentOptions = talent.split(',').map(function(item) {
        return item.trim();
      });

      if (talentOptions.length > 1)
      {
        talentSelector = new Roll(`1d${talentOptions.length} - 1`)
          await this._advanceTalent(talentOptions[talentSelector.roll().total])
      }
      else
      {
        await this._advanceTalent(talent)
      }
    }

  }

  async _advanceSkill(skillName, advances){
    let existingSkill = this.actor.data.items.find(i => i.name.trim() == skillName && i.type == "skill")
    if (existingSkill)
    {
      existingSkill.data.advances.value = (existingSkill.data.advances.value < advances) ? advances : existingSkill.data.advances.value;
      await this.actor.updateOwnedItem(existingSkill);
      return;
    }

    // If does not already own skill, search through compendium
    try
    {
        let skillToAdd = await WFRP_Utility.findSkill(skillName)
        skillToAdd.data.data.advances.value = advances;
        await this.actor.createOwnedItem(skillToAdd.data);
    }
    catch(error) {
      console.error("Something went wrong when adding skill " + skillName +": " + error);
      ui.notifications.error("Something went wrong when adding skill " + skillName +": " + error);
    }
  }

  async _advanceTalent(talentName){

    try
    {
      let talent = await WFRP_Utility.findTalent(talentName);
      await this.actor.createOwnedItem(talent.data);
    }
    catch(error) {
      console.error("Something went wrong when adding talent " + talentName +": " + error);
      ui.notifications.error("Something went wrong when adding talent " + talentName +": " + error);
    }
  }


  _modifyWounds(event)
  {
    let inputValue = event.target.value;
    let sign = event.target.value.split('')[0]
    let wounds;
    if (sign == "+" || sign == "-")
      wounds = eval(this.actor.data.data.status.wounds.value + parseInt(inputValue))
    else
      wounds = parseInt(inputValue);

    this.actor.update({"data.status.wounds.value" : wounds});
  }


  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Activate tabs
    new Tabs(html.find(".tabs"), {
      initial: this.actor.data.flags["_sheetTab"],
      callback: clicked => this.actor.data.flags["_sheetTab"] = clicked.attr("data-tab")
    });

    // Item summaries
    html.find('.item-dropdown').click(event => this._onItemSummary(event));

    html.find('.melee-property-quality, .melee-property-flaw, .ranged-property-quality, .ranged-property-flaw, .armour-quality, .armour-flaw').click(event => this._expandProperty(event));

    html.find('.weapon-range, .weapon-group, .weapon-reach').click(event => this._expandInfo(event));


    $("input[type=text]").click(function() {
      $(this).select();
   });

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

      html.find(".wounds-value-box").change(event => {
        this._modifyWounds(event)
      })

     // This disgusting mess allows characteristics to be tabbed through. (Used only by Creature and NPC sheets, placed here to maintain DRY code)
     html.find(".ch-edit").keydown(event => {
      if (event.keyCode == 9) // If Tabing out of an characteristic input, save the new value (and future values) in updateObj
      {
        let characteristics = this.actor.data.data.characteristics
        let ch = event.currentTarget.attributes["data-char"].value;
        let newValue  = Number(event.target.value);

        if (!this.updateObj) // Create a new updateObj (every time updateObj is used for an update, it is deleted, see below)
          this.updateObj = duplicate(this.actor.data.data.characteristics);;


        if (!(newValue == characteristics[ch].initial + characteristics[ch].advances)) // don't update a characteristic if it wasn't changed
        {
         this.updateObj[ch].initial = newValue;
         this.updateObj[ch].advances = 0;
        }
        this.charUpdateFlag = false;
      }
      else
      {
        this.charUpdateFlag = true; // If the user did not click tab, OK to update
      }
    })

    html.find('.ch-edit').focusout(async event => {
      event.preventDefault();
      if (!this.charUpdateFlag && event.currentTarget.attributes["data-char"].value != "fel") // Do not proceed with an update until the listener aboves sets this flag to true or the last characteristic was tabbed
        return                  // When this flag is true, that means the focus out was not from a tab

      // This conditional allows for correctly updating only a single characteristic. If the user editted only one characteristic, the above listener wasn't called, meaning no updateObj
      if (!this.updateObj)
        this.updateObj = duplicate(this.actor.data.data.characteristics)

      // In order to correctly update the last element, we use the normal procedure (similar to above)
      let characteristics = this.actor.data.data.characteristics
      let ch = event.currentTarget.attributes["data-char"].value;
      let newValue  = Number(event.target.value);

      if (!(newValue == characteristics[ch].initial + characteristics[ch].advances))
      {
       this.updateObj[ch].initial = newValue;
       this.updateObj[ch].advances = 0;
      }

      // Finally, update and delete the updateObj
      await this.actor.update({"data.characteristics" : this.updateObj})
      this.updateObj = undefined;

    });




    html.find('.skill-advances').keydown(async event => {
      if (event.keyCode == 9) // Wait to update if user tabbed to another skill
      {
        this.skillUpdateFlag = false;
      }
      else
      {
        this.skillUpdateFlag = true;
      }
    });


    html.find('.skill-advances').focusout(async event => {
      if (!this.skillsToEdit)
        this.skillsToEdit = []
      let itemId = Number(event.target.attributes["data-item-id"].value);
      let itemToEdit = this.actor.items.find(i => i.id === itemId);
      itemToEdit.data.advances.value = Number(event.target.value);
      this.skillsToEdit.push(itemToEdit);

      if (!this.skillUpdateFlag)
        return;

      // Need to update all skills every time because if the user tabbed through and updated many, only the last one would be saved
      for(let skill of this.skillsToEdit)
      {
        await this.actor.updateOwnedItem(skill, true);
      }
      this.skillsToEdit = [];
    });


    html.find('.skill-advances').focusin(async event => {
      event.target.focus();
    });

    html.find('.ammo-selector').change(async event => {
      let itemId = Number(event.target.attributes["data-item-id"].value);
      const itemToEdit = this.actor.items.find(i => i.id === itemId);
      itemToEdit.data.currentAmmo.value = Number(event.target.value);
      await this.actor.updateOwnedItem(itemToEdit, true);
    });


    html.find('.spell-selector').change(async event => {
      let itemId = Number(event.target.attributes["data-item-id"].value);
      const ing = this.actor.items.find(i => i.id === itemId);
      ing.data.spellIngredient.value = Number(event.target.value);
      await this.actor.updateOwnedItem(ing, true);
    });

    html.find('.ingredient-selector').change(async event => {
      let itemId = Number(event.target.attributes["data-item-id"].value);
      const spell = this.actor.items.find(i => i.id === itemId);
      spell.data.currentIng.value = Number(event.target.value);
      await this.actor.updateOwnedItem(spell, true);
    });

    // Characteristic Tests
    html.find('.ch-value').click(event => {
      event.preventDefault();
      let characteristic = event.currentTarget.attributes["data-char"].value;
      this.actor.setupCharacteristic(characteristic, event);
    });

    html.find('.skill-total').click(event => {
      event.preventDefault();
      let itemId = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let skill = this.actor.items.find(i => i.id === itemId);
      this.actor.setupSkill(skill, event);
    })

    html.find('.weapon-item-name').click(event => {
      event.preventDefault();
      let itemId = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let attackType = $(event.currentTarget).parents(".inventory-list").attr("data-weapon-type");
      let weapon = this.actor.items.find(i => i.id === itemId);
      this.actor.setupWeapon(duplicate(weapon), {attackType : attackType});
    })

    html.find('.fist-icon').click(async event => {
      event.preventDefault();
      let pack = game.packs.find(p => p.collection == "wfrp4e.trappings");
      let weapons;
      await pack.getIndex().then(index => weapons = index);
      let unarmedId = weapons.find(w => w.name.toLowerCase() == "unarmed");
      let unarmed = await pack.getEntity(unarmedId.id);
      this.actor.setupWeapon(duplicate(unarmed.data), {attackType : "melee"})
      // Roll Fist Attack
    })

    html.find('.trait-roll').click(event => {
      event.preventDefault();
      let itemId = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let trait = this.actor.items.find(i => i.id === itemId);
      this.actor.rollTrait((duplicate(trait)));
    })

    html.find('.spell-roll').click(event => {
      event.preventDefault();
      let itemId = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let spell = this.actor.items.find(i => i.id === itemId);
      this.actor.spellDialog(duplicate(spell));
    })

    html.find('.prayer-roll').click(event => {
      event.preventDefault();
      let itemId = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let prayer = this.actor.items.find(i => i.id === itemId);
      this.actor.setupPrayer(duplicate(prayer));
    })

    /* -------------------------------------------- */
    /*  Inventory
    /* -------------------------------------------- */

    // Create New Item
    html.find('.item-create').click(ev => this._onItemCreate(ev));


    // Update Inventory Item
    html.find('.item-edit').click(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let Item = CONFIG.Item.entityClass;
      const item = new Item(this.actor.items.find(i => i.id === itemId), {actor : this.actor});
      item.sheet.render(true);
    });

    // Link Inventory Item to Chat
    html.find('.item-link').click(ev => {
        let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
        let Item = CONFIG.Item.entityClass;
        const actorItem = new Item(this.actor.items.find(i => i.id === itemId), {actor: this.actor});
        let item = actorItem.data;

        if (item.data.qualities) {
            item["properties"] = WFRP_Utility._separateQualitiesFlaws(WFRP_Utility._prepareQualitiesFlaws(item));
        }
        if (item.data.reach) {
            item.data.reach.value = CONFIG.weaponReaches[item.data.reach.value];
        }
        if (item.data.weaponGroup) {
            item.data.weaponGroup.value = CONFIG.weaponGroups[item.data.weaponGroup.value];
        }
        if (item.data.armorType) {
            item.data.armorType.value = CONFIG.armorTypes[item.data.armorType.value];
        }
        if (item.data.availability) {
            item.data.availability.value = CONFIG.availability[item.data.availability.value];
        }
        if (item.data.ammunitionGroup) {
          if (item.data.ammunitionGroup.value == "none") {
              item.data.ammunitionGroup.value = '';
          } else {
              item.data.ammunitionGroup.value = CONFIG.ammunitionGroups[item.data.ammunitionGroup.value];
          }
        }

        let chatOptions = {
            user: game.user._id,
            speaker: {
                alias: this.actor.name
            },
            template: "public/systems/wfrp4e/templates/chat/item-card.html",
        };
        let chatData = {
            title: chatOptions.title,
            item: item
        };

        renderTemplate(chatOptions["template"], chatData).then(html => {
            console.log(chatData.item);
            chatOptions["content"] = html;
            chatOptions["type"] = 0;
            ChatMessage.create(chatOptions, false);

            return html;
        });
    });

    html.find('.skill-select').mousedown(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      if (ev.button == 0)
      {
        let skill = this.actor.items.find(i => i.id === itemId);
        this.actor.setupSkill(skill, event);
      }
      else if (ev.button == 2)
      {
        let Item = CONFIG.Item.entityClass;
        const item = new Item(this.actor.items.find(i => i.id === itemId), {actor : this.actor});
        item.sheet.render(true);
      }
    });


    // Delete Inventory Item
    html.find('.item-delete').click(ev => {
      let li = $(ev.currentTarget).parents(".item"),
        itemId = Number(li.attr("data-item-id"));
        renderTemplate('public/systems/wfrp4e/templates/chat/delete-item-dialog.html').then(html => {
          new Dialog({
          title: "Delete Confirmation",
          content: html,
          buttons: {
            Yes: {
              icon: '<i class="fa fa-check"></i>',
              label: "Yes",
              callback: dlg => {
                this.actor.deleteOwnedItem(itemId, true);
                li.slideUp(200, () => this.render(false));
              }
            },
            cancel: {
              icon: '<i class="fas fa-times"></i>',
              label: "Cancel"
            },
          },
          default: 'Yes'
        }).render(true)
    });
  });

    // Remove Inventory Item from Container
    html.find('.item-remove').click(ev => {
      let li = $(ev.currentTarget).parents(".item"),
        itemId = Number(li.attr("data-item-id"));
      const item = this.actor.items.find(i => i.id == itemId);
      item.data.location.value = 0;
      this.actor.updateOwnedItem(item, true);
    });

    html.find('.toggle-enc').click(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let item = this.actor.items.find(i => i.id === itemId );
      item.data.countEnc.value = !item.data.countEnc.value;
      this.actor.updateOwnedItem(item, true);
    });

    html.find('.item-toggle').click(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let item = this.actor.items.find(i => i.id === itemId );
      if (item.type == "armour")
        item.data.worn.value = !item.data.worn.value;
      else if (item.type == "weapon")
        item.data.equipped = !item.data.equipped;
      else if (item.type == "trapping" && item.data.trappingType.value == "clothingAccessories")
        item.data.worn = !item.data.worn;
      this.actor.updateOwnedItem(item);
    });

    html.find('.worn-container').click(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let item = this.actor.items.find(i => i.id === itemId );
      item.data.worn.value = !item.data.worn.value;
      this.actor.updateOwnedItem(item, true);
    });


    html.find('.quantity-click').mousedown(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let item = this.actor.items.find(i => i.id === itemId );
      switch (event.button)
      {
        case 0:
          if (event.ctrlKey)
            item.data.quantity.value += 10;
          else
            item.data.quantity.value++;

          break;
        case 2:
          if (event.ctrlKey)
            item.data.quantity.value -= 10;
          else
            item.data.quantity.value--;

          if (item.data.quantity.value < 0)
            item.data.quantity.value = 0;
          break;
      }
      this.actor.updateOwnedItem(item);
    });

    html.find('.ap-value').mousedown(ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let APlocation =  $(ev.currentTarget).parents(".item").attr("data-location");
      let item = this.actor.items.find(i => i.id === itemId );
      if (item.data.currentAP[APlocation] == -1)
        item.data.currentAP[APlocation] = item.data.maxAP[APlocation];
      switch (event.button)
      {
        case 0:
        item.data.currentAP[APlocation]++;
        if (item.data.currentAP[APlocation] > item.data.maxAP[APlocation])
          item.data.currentAP[APlocation] = item.data.maxAP[APlocation]
          break;
        case 2:
        item.data.currentAP[APlocation]--;
        if (item.data.currentAP[APlocation] < 0)
          item.data.currentAP[APlocation] = 0;
          break;
      }
      this.actor.updateOwnedItem(item);
    });

    html.find('.memorized-toggle').click(async ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      const spell = this.actor.items.find(i => i.id === itemId);
      spell.data.memorized.value = !spell.data.memorized.value;
      await this.actor.updateOwnedItem(spell, true);
    });

    html.find('.sl-counter').mousedown(async ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      const spell = this.actor.items.find(i => i.id === itemId);
      switch (event.button)
      {
        case 0:
        spell.data.cn.SL++;
        if (spell.data.cn.SL > spell.data.cn.value)
          spell.data.cn.SL = spell.data.cn.valeu;
          break;
        case 2:
        spell.data.cn.SL = 0;
        break;
      }
      await this.actor.updateOwnedItem(spell, true);
    });

    html.find('.auto-calc-toggle').mousedown(async ev => {
      let toggle = event.target.attributes["toggle-type"].value;

      if (event.button == 2)
      {
        let newFlags = duplicate(this.actor.data.flags);

        if (toggle == "walk")
          newFlags.autoCalcWalk = !newFlags.autoCalcWalk;

        else if (toggle == "run")
          newFlags.autoCalcRun = !newFlags.autoCalcRun;

        else if (toggle == "wounds")
          newFlags.autoCalcWounds = !newFlags.autoCalcWounds;

        else if (toggle == "critW")
          newFlags.autoCalcCritW = !newFlags.autoCalcCritW;

        else if (toggle == "corruption")
          newFlags.autoCalcCorruption = !newFlags.autoCalcCorruption;

        else if (toggle == "encumbrance")
          newFlags.autoCalcEnc = !newFlags.autoCalcEnc;


        this.actor.update({'flags' : newFlags})

      }

    });

    html.find('.disease-roll').mousedown(async ev =>  {
      console.log("DISEASE ROLL");
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      const disease = this.actor.items.find(i => i.id === itemId);
      let type = ev.target.attributes.class.value.split(" ")[0].trim(); // Incubation or duration

      if (ev.button == 0)
      {
        try
        {
          let rollValue = new Roll(disease.data[type].value.split(" ")[0]).roll().total
          let timeUnit = disease.data[type].value.split(" ")[1];
          disease.data[type].roll = rollValue.toString() + " " + timeUnit;
        }
        catch
        {
          disease.data[type].roll = disease.data[type].value;
        }

        this.actor.updateOwnedItem(disease);
      }
      else if (ev.button == 2)
      {
        if(disease.data[type].roll)
        {
          let number = Number(disease.data[type].roll.split(" ")[0]) - 1;
          let timeUnit = disease.data[type].roll.split(" ")[1];
          disease.data[type].roll = `${number} ${timeUnit}`;
        }
        this.actor.updateOwnedItem(disease);
      }
    });

    /*****************************************************
    * Randomization options used by NPC and Creature sheets
    ******************************************************/

    // Entering a recognized species sets the characteristics to the average values
    html.find('.input.species').focusout(async event => {
      event.preventDefault();
      if (this.actor.data.type == "character")
        return
      if (game.settings.get("wfrp4e", "npcSpeciesCharacteristics"))
      {
        let species = event.target.value;
        try
        {
          let initialValues = WFRP_Utility.speciesCharacteristics(species, true);
          let characteristics = duplicate(this.actor.data.data.characteristics);

          for (let c in characteristics)
          {
            characteristics[c].initial = initialValues[c];
          }


          await this.actor.update({'data.characteristics' : characteristics})
          await this.actor.update({"data.details.species.value" : species});
          await this.actor.update({"data.details.move.value" : WFRP_Utility.speciesMovement(species) || 4})
        }
        catch
        {
          // Do nothing if exception trying to find species
        }
      }
    });

    // Randomization buttons that randomize characteristics, skills, and talents, of a recognized species
    html.find('.randomize').click(async event => {
      event.preventDefault();
      let species = this.actor.data.data.details.species.value;

      try
      {
        switch(event.target.text)
        {
          case "C":
            if (this.actor.data.type == "creature")
            {
              let roll = new Roll("2d10");
              roll.roll();
              let characteristics = duplicate (this.actor.data.data.characteristics);
              for (let char in characteristics)
              {
                if (characteristics[char].initial == 0)
                  continue

                characteristics[char].initial -= 10;
                characteristics[char].initial += roll.reroll().total;
                if (characteristics[char].initial < 0)
                  characteristics[char].initial = 0
              }
              await this.actor.update({"data.characteristics" : characteristics});
            }
            else
            {
              let characteristics = duplicate (this.actor.data.data.characteristics);
              let rolledCharacteristics = WFRP_Utility.speciesCharacteristics(species, false);
              for (let char in rolledCharacteristics)
              {
                characteristics[char].initial = rolledCharacteristics[char];
              }
              await this.actor.update({"data.characteristics" : characteristics})

            }
            return

          case "S":
            this._advanceSpeciesSkills()
            return

          case "T":
            this._advanceSpeciesTalents()
            return
        }
      }
      catch (error)
      {
        console.log("Could not randomize: " + error)
      }
    });


    //Item Dragging
    let handler = ev => this._onDragItemStart(ev);
    html.find('.item').each((i, li) => {
      li.setAttribute("draggable", true);
      li.addEventListener("dragstart", handler, false);
    });
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers                */
  /* -------------------------------------------- */

  _onDragItemStart(event) {
    let itemId = Number(event.currentTarget.getAttribute("data-item-id"));
    event.dataTransfer.setData("text/plain", JSON.stringify({
      type: "Item",
      actorId: this.actor._id,
      id: itemId,
      root: Number(event.currentTarget.getAttribute("root"))
    }));
  }

  async _onDrop(event) {
      var dragData = event.dataTransfer.getData("text/plain");
      var dropID = Number($(event.target).parents(".item").attr("data-item-id"));
      if ($(event.target).parents(".item").attr("inventory-type") == "container"){
        var dragItem = this.actor.getOwnedItem(JSON.parse(dragData).id);
        if (dragItem.data.id == dropID)
          throw "";
        else if (dragItem.data.type == "container" && $(event.target).parents(".item").attr("last-container"))
           throw "Cannot add container past the 4th nested container"

        else if (dragItem.data.type == "container")
        {
          if (JSON.parse(dragData).root == $(event.target).parents(".item").attr("root"))
          {
            ui.notifications.error("Remove the container before changing its location");
            throw "Remove the container before changing its location";
          }
        }
        dragItem.data.data.location.value = dropID;

          //  this will unequip/remove items like armor and weapons when moved into a container
          if (dragItem.data.type == "armour")
            dragItem.data.data.worn.value = false;
          if (dragItem.data.type == "weapon")
            dragItem.data.data.equipped = false;
          if (dragItem.data.type == "trapping" && dragItem.data.data.trappingType.value == "clothingAccessories")
            dragItem.data.data.worn = false;


        await this.actor.updateOwnedItem(dragItem.data, true);
      }
    else
      super._onDrop(event)
  }


  _onItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parents(".item"),
        item = this.actor.getOwnedItem(Number(li.attr("data-item-id"))),
        expandData = item.getExpandData({secrets: this.actor.owner});

    // Toggle summary for an item
    if ( li.hasClass("expanded") ) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = "";
      div = $(`<div class="item-summary">${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }

  // Summary for specific property selected - like a Quality description
  _expandProperty(event) {
    event.preventDefault();

    let li = $(event.currentTarget).parents(".item"),
        property = event.target.text,
        properties = mergeObject(WFRP_Utility.qualityList(), WFRP_Utility.flawList()),
        propertyDescr = Object.assign(duplicate(CONFIG.qualityDescriptions), CONFIG.flawDescriptions);

        property = property.replace(/,/g, '').trim();

        let propertyKey = "";
        if (property == "Special Ammo")
        {
          let item = this.actor.getOwnedItem(Number(li.attr("data-item-id")));
          let ammo = this.actor.getOwnedItem(item.data.data.currentAmmo.value);
          propertyDescr = Object.assign(propertyDescr, {"Special Ammo" : ammo.data.data.special.value});
          propertyKey = "Special Ammo";
        }
        else if (property != "Special")
        {
          propertyKey = WFRP_Utility.findKey(property.split(" ")[0], properties)
        }
        else{
          let item = this.actor.getOwnedItem(Number(li.attr("data-item-id")));
          propertyDescr = Object.assign(propertyDescr, {"Special" : item.data.data.special.value});
          item = WFRP_Utility._prepareWeaponCombat(this.actor.data, duplicate(item.data));
          propertyKey = "Special";
        }

        let propertyDescription = "<b>" + property + "</b>" + ": " + propertyDescr[propertyKey];
        if (propertyDescription.includes("(Rating)"))
          propertyDescription = propertyDescription.replace("(Rating)", property.split(" ")[1])

    // Toggle summary
    if ( li.hasClass("expanded") ) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = $(`<div class="item-summary">${propertyDescription}</div>`);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }

  _expandInfo(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parents(".item");
    let classes = $(event.currentTarget);
    let  expansionText = "";
      if (classes.hasClass("weapon-range"))
      {
        let range = parseInt(event.target.text);
        expansionText = "0 yd - " + Math.ceil(range / 10) + " yds: " + CONFIG.rangeModifiers["Point Blank"] + "<br>"+
        (Math.ceil(range / 10) + 1) + " yds - " + Math.ceil(range / 2) + " yds: " + CONFIG.rangeModifiers["Short Range"] + "<br>" +
        (Math.ceil(range / 2) + 1) + " yds - " + range + " yds: " + CONFIG.rangeModifiers["Normal"]  + "<br>"+
        (range + 1) + " yds - " + range * 2 + " yds: " + CONFIG.rangeModifiers["Long Range"] + "<br>"+
        (range * 2 + 1) + " yds - " + range * 3 + " yds: " + CONFIG.rangeModifiers["Extreme"] + "<br>";
      }
      else if (classes.hasClass("weapon-group"))
      {
        let weaponGroup = event.target.text;
        let weaponGroupKey = "";
        weaponGroupKey = WFRP_Utility.findKey(weaponGroup, CONFIG.weaponGroups);
        expansionText = CONFIG.weaponGroupDescriptions[weaponGroupKey];
      }
      else if (classes.hasClass("weapon-reach"))
      {
        let reach = event.target.text;
        let reachKey;
        reachKey = WFRP_Utility.findKey(reach, CONFIG.weaponReaches);
        expansionText = CONFIG.reachDescription[reachKey];
      }

    // Toggle summary

    if ( li.hasClass("expanded") ) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = $(`<div class="item-summary">${expansionText}</div>`);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }

  /* -------------------------------------------- */

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   * @private
   */
  _onItemCreate(event) {
    event.preventDefault();
    let header = event.currentTarget,
        data = duplicate(header.dataset);


    // Conditional for creating skills from the skills tab - sets to the correct skill type depending on column
    if (event.currentTarget.attributes["data-type"].value == "skill")
    {
      data = mergeObject(data, {"data.advanced.value" : event.currentTarget.attributes["data-skill-type"].value});
    }

    // Conditional for creating Trappings from the Trapping tab - sets to the correct trapping type
    if (event.currentTarget.attributes["data-type"].value == "trapping")
      data = mergeObject(data, {"data.trappingType.value" : event.currentTarget.attributes["item-section"].value})

    // Conditional for creating spells/prayers from their tabs, create the item with the correct type
    else if (data.type == "spell" || data.type == "prayer")
    {
      let itemSpecification = event.currentTarget.attributes[`data-${data.type}-type`].value;

      if (data.type == "spell")
      {
        data = mergeObject(data, {"data.lore.value" : itemSpecification});
      }
      else if (data.type == "prayer")
      {
        data = mergeObject(data, {"data.type.value" : itemSpecification});
      }
    }
    data["img"] = "systems/wfrp4e/icons/blank.png";
    data["name"] = `New ${data.type.capitalize()}`;
    this.actor.createOwnedItem(data, true, {renderSheet: true});
  }

  /* -------------------------------------------- */
}

Actors.unregisterSheet("core", ActorSheet);




class ActorSheetWfrp4eCharacter extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options, {
      classes: options.classes.concat(["wfrp4e", "actor", "character-sheet"]),
      width: 610,
      height: 740,
    });
    return options;
  }

  /* -------------------------------------------- */

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    return "public/systems/wfrp4e/templates/actors/actor-sheet.html";
  }

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  getData() {
    const sheetData = super.getData();
    let tb = sheetData.actor.data.characteristics.t.bonus;
    let wpb =sheetData.actor.data.characteristics.wp.bonus;
    if (sheetData.actor.flags.autoCalcCorruption)
    {
      sheetData.actor.data.status.corruption.max = tb + wpb;
      let pureSoulTalent = sheetData.actor.talents.find(x => x.name.toLowerCase() == "pure soul")
      if (pureSoulTalent)
        sheetData.actor.data.status.corruption.max += pureSoulTalent.data.advances.value;
    }


    return sheetData;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('.career-toggle').click(async ev => {
      let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
      let type = $(ev.currentTarget).attr("toggle-type")
      let item = this.actor.items.find(i => i.id === itemId );
      item.data[type].value = !item.data[type].value;


       if (type == "current")
       {
         let availableCharacteristics = item.data.characteristics
         let characteristics = this.actor.data.data.characteristics;
         if (item.data.current.value)
         {
           for (let char in characteristics)
           {
             characteristics[char].career = false;
             if (availableCharacteristics.includes(char))
               characteristics[char].career = true;
           }
         }
         else
         {
           for (let char in characteristics)
           {
             characteristics[char].career = false;
           }
         }
      this.actor.update({"data.characteristics" : characteristics})
      }

      // Only one career can be current - make all other careers not current
      // Dislike iterating through every item: TODO - different approach
      if (type == "current" && item.data.current.value == true)
        for (let i of this.actor.items)
          if (i.type == "career" && i != item)
            await this.actor.updateOwnedItem({"id" : i.id, "data.current.value" : false});
      this.actor.updateOwnedItem(item);
    });

    html.find(".untrained-skill").mousedown(async ev => {

      let skill = await WFRP_Utility.findSkill(event.target.text);

      if (ev.button == 2)
      {
        skill.sheet.render(true);
      }
      else
      {
        try
        {
          new Dialog({
            title: "Add Career Skill",
            content: '<p>Do you want to add this skill?</p>',
            buttons: {
              yes: {
                label: "Yes",
                callback: dlg => {
                  this.actor.createOwnedItem(skill.data);
                }
              },
              cancel: {
                label: "Cancel",
                callback: dlg => {
                  return
                }
              },
            },
            default: 'yes'
          }).render(true);
        }
        catch
        {
          console.error(error)
          ui.notifications.error(error)
        }
      }
    })

    html.find(".untrained-talent").mousedown(async ev => {

      let talent = await WFRP_Utility.findTalent(event.target.text);

      if (ev.button == 2)
      {
        talent.sheet.render(true);
      }

      else
      {
        try
        {
          new Dialog({
            title: "Add Career Talent",
            content: '<p>Do you want to add this Talent?</p>',
            buttons: {
              yes: {
                label: "Yes",
                callback: dlg => {
                  this.actor.createOwnedItem(talent.data);
                  // this.actor.update({"data.details.experience.spent" : this.actor.data.data.details.experience.spent + 100})
                }
              },
              cancel: {
                label: "Cancel",
                callback: dlg => {
                  return
                }
              },
            },
            default: 'yes'
          }).render(true);
        }
        catch
        {
          console.error(error)
          ui.notifications(error)
        }
    }

    })

    html.find('.advancement-indicator').mousedown(async ev =>  {
     let data = duplicate(this.actor.data.data);

      let type = $(ev.target).attr("data-target");

      if (type == "skill")
      {
        let itemId = Number($(ev.currentTarget).parents(".item").attr("data-item-id"));
        let item = this.actor.getOwnedItem(itemId);

        if (ev.button == 0)
        {
          let cost = WFRP_Utility._calculateAdvCost(item.data.data.advances.value, type)
          data.details.experience.spent = Number(data.details.experience.spent) + cost;
          item.data.data.advances.value++;
          this.actor.updateOwnedItem({id : itemId, "data.advances.value": item.data.data.advances.value});
          this.actor.update({"data.details.experience.spent" : data.details.experience.spent});
        }
        else if (ev.button = 2)
        {
          if (item.data.data.advances.value == 0)
            return;
          item.data.data.advances.value--;
          let cost = WFRP_Utility._calculateAdvCost(item.data.data.advances.value, type)
          data.details.experience.spent = Number(data.details.experience.spent) - cost;
          this.actor.updateOwnedItem({id : itemId, "data.advances.value": item.data.data.advances.value});
          this.actor.update({"data.details.experience.spent" : data.details.experience.spent});
        }
      }
      else if (type == "talent")
      {

      }
      else
      {
        let characteristic = type;
        let currentChar = this.actor.data.data.characteristics[characteristic];

        if (ev.button == 0)
        {
          let cost = WFRP_Utility._calculateAdvCost(currentChar.advances, "characteristic");

          data.characteristics[characteristic].advances++;
          data.details.experience.spent = Number(data.details.experience.spent) + cost;
          await this.actor.update({"data.characteristics" : data.characteristics,
                                  "data.details.experience" : data.details.experience});
        }
        else if (ev.button == 2)
        {
          if (currentChar.advances == 0)
            return
          let cost = WFRP_Utility._calculateAdvCost(currentChar.advances - 1, "characteristic");

          data.characteristics[characteristic].advances--;
          data.details.experience.spent = Number(data.details.experience.spent) - cost;
          await this.actor.update({"data.characteristics" : data.characteristics,
                                  "data.details.experience" : data.details.experience});
        }
      }
  });
  }
}

// Register Character Sheet
Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCharacter, {
  types: ["character"],
  makeDefault: true
});



class ActorSheetWfrp4eNPC extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options, {
      classes: options.classes.concat(["wfrp4e", "actor", "npc-sheet"]),
      width: 610,
      height: 740,
    });


    return options;
  }


  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    return "public/systems/wfrp4e/templates/actors/npc-sheet.html";
  }


  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  getData() {
    const sheetData = super.getData();

    // Return data for rendering
    return sheetData;
  }

  /* -------------------------------------------- */

  /**
   * Organize and classify Items for NPC sheets
   * @private
   */
  _prepareItems(actorData) {
   super._prepareItems(actorData);
  }


    /**
   * Advance NPC based on given career
   * @private
   */
  async _advanceNPC(careerData) {
    let updateObj = {};
    let advancesNeeded = careerData.level.value * 5;

    for (let advChar of careerData.characteristics)
      if (this.actor.data.data.characteristics[advChar].advances < 5 * careerData.level.value)
        updateObj[`data.characteristics.${advChar}.advances`] = 5 * careerData.level.value;

    for (let skill of careerData.skills)
      await this._advanceSkill(skill, advancesNeeded);

    for (let talent of careerData.talents)
      await this._advanceTalent(talent);

    this.actor.update(updateObj);
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    if (!this.options.editable) return;

      html.find('.ch-roll').click(event => {
        event.preventDefault();
        let characteristic = $(event.currentTarget).attr("data-char");
        this.actor.setupCharacteristic(characteristic, event);
      });



      html.find('.npc-career').click(event => {
        event.preventDefault();
        let id = Number($(event.currentTarget).parents(".item").attr("data-item-id"));
        let careerItem = duplicate(this.actor.getOwnedItem(id).data);
        careerItem.data.complete.value = !careerItem.data.complete.value
        if (careerItem.data.complete.value)
          this._advanceNPC(careerItem.data)

        this.actor.updateOwnedItem({id : id, 'data' : careerItem.data});
      });
  }

  /* -------------------------------------------- */

  /**
   * This method is called upon form submission after form data is validated
   * @param event {Event}       The initial triggering submission event
   * @param formData {Object}   The object of validated form data with which to update the object
   * @private
   */
  _updateObject(event, formData) {

    // Parent ActorSheet update steps
    super._updateObject(event, formData);
  }
}

// Register NPC Sheet
Actors.registerSheet("wfrp4e", ActorSheetWfrp4eNPC, {
  types: ["npc"],
  makeDefault: true
});


/************** ALTERNATE CREATURE SHEET ******************/

class ActorSheetWfrp4eCreature extends ActorSheetWfrp4e {
  static get defaultOptions() {
    const options = super.defaultOptions;
    mergeObject(options, {
      classes: options.classes.concat(["wfrp4e", "actor", "creature-sheet"]),
      width: 610,
      height: 740,
    });


    return options;
  }

  /* -------------------------------------------- */

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   * @type {String}
   */
  get template() {
    return "public/systems/wfrp4e/templates/actors/creature-sheet.html";
  }

  /* -------------------------------------------- */

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  getData() {
    const sheetData = super.getData();
    // Return data for rendering
    return sheetData;
  }

  /* -------------------------------------------- */

  /**
   * Organize and classify Items for NPC sheets
   * @private
   */
  _prepareItems(actorData) {
   super._prepareItems(actorData);

   for (let trait of actorData.traits)
   {
     if (actorData.data.excludedTraits.includes(trait.id))
     {
       trait.included = false;
     }
     else
     {
       trait.included = true;
     }
   }

   actorData.notesTraits = actorData.traits.sort(WFRP_Utility.nameSorter); // Display all traits in the notes section of a creature
   // Use only included traits for calculation
   actorData.traits = actorData.traits.filter(t => t.included);

   actorData.skills = (actorData.basicSkills.concat(actorData.advancedOrGroupedSkills)).sort(WFRP_Utility.nameSorter);
   actorData.trainedSkills = actorData.skills.filter(s => s.data.advances.value > 0)

   for (let weapon of actorData.weapons)
   {
     if (weapon.data.currentAmmo.value)
      weapon.ammoName = actorData.inventory.ammunition.items.find(a => a.id == weapon.data.currentAmmo.value).name;
   }

  }


  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);
  }

  /* -------------------------------------------- */

  /**
   * This method is called upon form submission after form data is validated
   * @param event {Event}       The initial triggering submission event
   * @param formData {Object}   The object of validated form data with which to update the object
   * @private
   */
  _updateObject(event, formData) {

    // Parent ActorSheet update steps
    super._updateObject(event, formData);
  }

  // Creature sheet dropdowns need specific implementation to correctly display
  _onCreatureItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parent('.list'),
        item = this.actor.getOwnedItem(Number($(event.currentTarget).attr("data-item-id"))),
        expandData = item.getExpandData({secrets: this.actor.owner});


    if ( li.hasClass("expanded") ) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = "";
      div = $(`<div class="item-summary"><b>${item.data.name}:</b>${expandData.description.value}</div>`);

      let props = $(`<div class="item-properties"></div>`);
      expandData.properties.forEach(p => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }
  activateListeners(html) {
    super.activateListeners(html);

    html.find(".content").hover(event => {
      $(event.currentTarget).focus();
    })
    html.find('.content').keydown(event => {
      if (event.keyCode == 46)
      {
        let itemId = $(event.currentTarget).attr("data-item-id");
        this.actor.deleteOwnedItem(itemId, true);
      }
    });
    html.find(".creature-dropdown").click(event => this._onCreatureItemSummary(event));

    if (!this.options.editable) return;

    html.find(".skills.name, .skills.total").mousedown(event => {
      let newAdv
      let advAmt;
      let skill = this.actor.getOwnedItem(Number($(event.currentTarget).parents(".content").attr("data-item-id")));

      if (event.shiftKey || event.ctrlKey)
      {
        if (event.shiftKey)
          advAmt = 10;
        else if (event.ctrlKey)
          advAmt = 1;
      }

      if (event.button == 0)
      {
        if (advAmt)
        {
          newAdv = skill.data.data.advances.value + advAmt;
          this.actor.updateOwnedItem({id: skill.data.id, "data.advances.value" : newAdv})
        }
        else
          this.actor.setupSkill(skill.data);
      }
      else if (event.button == 2)
      {
        if (advAmt)
        {
          newAdv = skill.data.data.advances.value - advAmt;
          if (newAdv < 0)
            newAdv = 0;
          this.actor.updateOwnedItem({id: skill.data.id, "data.advances.value" : newAdv})
        }
        else
        {
          let itemId = Number($(event.currentTarget).parents(".content").attr("data-item-id"));
          let Item = CONFIG.Item.entityClass;
          const item = new Item(this.actor.items.find(i => i.id === itemId), {actor : this.actor});
          item.sheet.render(true);
        }
      }
    })

    html.find(".traits.content").mousedown(event => {
      let trait = this.actor.getOwnedItem(Number($(event.currentTarget).attr("data-item-id")));

      if (event.button == 2 || !trait.data.data.rollable.value)
      {
        this._onCreatureItemSummary(event);
        return;
      }

      this.actor.rollTrait(trait.data);

    })

    html.find('.ch-roll').click(event => {
      event.preventDefault();
      let characteristic = $(event.currentTarget).attr("data-char");
      this.actor.setupCharacteristic(characteristic, event);
    });

    html.find('.trait-name').click(async event => {
      event.preventDefault();
      let traitId =  Number($(event.currentTarget).parents(".item").attr("data-item-id"));
      let newExcludedTraits = duplicate(this.actor.data.data.excludedTraits);

      if (this.actor.data.data.excludedTraits.includes(traitId))
        newExcludedTraits = newExcludedTraits.filter(i => i != traitId)
      else
        newExcludedTraits.push(traitId);

        await this.actor.update({"data.excludedTraits" : newExcludedTraits});
        this.actor.sheet.render(true);
    });
  }

}

// Register Creature Sheet
Actors.registerSheet("wfrp4e", ActorSheetWfrp4eCreature, {
  types: ["creature"],
  makeDefault: false
});




class WFRP_Utility
{
  static _prepareSpellOrPrayer(actorData, item) {
    item['target'] = this._calculateSpellRangeOrDuration(actorData, item.data.target.value, item.data.target.aoe);
    item['duration'] = this._calculateSpellRangeOrDuration(actorData, item.data.duration.value);
    if (item.data.duration.extendable)
    {
      item.duration += "+";
    }
    item['range'] = this._calculateSpellRangeOrDuration(actorData, item.data.range.value);
    if (item.type == "spell")
      item['damage'] = this._calculateSpellDamage(actorData, item.data.damage.value, item.data.magicMissile.value);
    else
      item['damage'] = this._calculateSpellDamage(actorData, item.data.damage.value, false);

    if (item.type == "spell")
    {
      item.data.description.value = this._spellDescription(item);
      if (!item.data.memorized.value )
        item.data.cn.value *= 2;
    }

    return item;
  }

  static _spellDescription (spell) {
    let description = spell.data.description.value;
    if (description && description.includes ("Lore:"))
      return description
    if (spell.data.lore.effect)
      description += "\n\n <b>Lore:</b> " + spell.data.lore.effect;
    else if (CONFIG.loreEffect[spell.data.lore.value])
      description += "\n\n <b>Lore:</b> " + CONFIG.loreEffect[spell.data.lore.value];
    return description;
  }

  /* -------------------------------------------- */

  static _prepareSkill(actorData, basicSkills, advOrGrpSkills, skill) {

    skill.data.characteristic.num = actorData.data.characteristics[skill.data.characteristic.value].value;
    skill.data.total.value = actorData.data.characteristics[skill.data.characteristic.value].value + skill.data.advances.value;
    skill.data.characteristic.abrev = CONFIG.characteristicsAbbrev[skill.data.characteristic.value];

    if (skill.data.grouped.value == "isSpec" || skill.data.advanced.value == "adv")
      advOrGrpSkills.push(skill)
    else
      basicSkills.push(skill);
   }

  /* -------------------------------------------- */

   static  _prepareTalent(actorData, talent, talentList) {
    let existingTalent = talentList.find(t => t.name == talent.name)
    if (existingTalent){
      if (!existingTalent.numMax){
        talent["numMax"]= actorData.data.characteristics[talent.data.max.value].bonus;
      }
        existingTalent.data.advances.value++;
    }
    else{
      switch(talent.data.max.value){
        case '1':
        talent["numMax"] = 1;
        break;

        case '2':
        talent["numMax"] = 2;
        break;

        case 'none':
        talent["numMax"] = "-";
        break;

        default:
        talent["numMax"]= actorData.data.characteristics[talent.data.max.value].bonus;
      }
      talentList.push(talent);
    }
   }

  /* -------------------------------------------- */

  // Prepare a weapon to be displayed in the combat tab (assign ammo, calculate range, organize qualities/flaws)
  static _prepareWeaponCombat(actorData, weapon){
    weapon["properties"] = this._prepareQualitiesFlaws(weapon);
    weapon.data.reach.value = CONFIG.weaponReaches[weapon.data.reach.value];
    weapon.data.weaponGroup.value = CONFIG.weaponGroups[weapon.data.weaponGroup.value];

    weapon.data.range.value = this._calculateRangeOrDamage(actorData, weapon.data.range.value);
    weapon.data.damage.meleeValue = this._calculateRangeOrDamage(actorData, weapon.data.damage.meleeValue);
    weapon.data.damage.rangedValue = this._calculateRangeOrDamage(actorData, weapon.data.damage.rangedValue);

    if (Number(weapon.data.range.value) > 0)
        weapon["rangedWeaponType"] = true;
    if (weapon.data.reach.value)
      weapon["meleeWeaponType"] = true;

    // assign available ammo (TODO: Improve by keeping a constant list of ammo so a loop each time is necessary)
    if (weapon.data.ammunitionGroup.value != "none") {
      weapon["ammo"] = [];
      for ( let a of actorData.items ) {
        if (a.type == "ammunition" && a.data.ammunitionType.value == weapon.data.ammunitionGroup.value) // If is ammo and the correct type of ammo
            weapon.ammo.push(a);
      }
      this._prepareWeaponWithAmmo(actorData, weapon);
    }
    else if (weapon.data.weaponGroup.value == "Throwing" || weapon.data.weaponGroup.value == "Explosives")
    {
      weapon["ammo"] = [weapon];
      weapon.data.ammunitionGroup.value = "";
    }
    weapon.properties = WFRP_Utility._separateQualitiesFlaws(weapon.properties);
    if (weapon.properties.special)
      weapon.properties.special = weapon.data.special.value;
    return weapon;
  }

  /* -------------------------------------------- */

  // Prepare a weapon to be displayed in the combat tab (calculate APs, organize qualities/flaws)
  static _prepareArmorCombat(actorData, armor, AP){ // -1 means currentAP is maxAP
    for (let ap in armor.data.currentAP)
    {
      if (armor.data.currentAP[ap] == -1)
      {
        armor.data.currentAP[ap] = armor.data.maxAP[ap];
      }
    }

    if (armor.data.maxAP.head > 0)
    {
      armor["protectsHead"] = true;
      AP.head += armor.data.currentAP.head;
    }
    if (armor.data.maxAP.body > 0)
    {
      armor["protectsBody"] = true;
      AP.body += armor.data.currentAP.body;
    }
    if (armor.data.maxAP.lArm > 0)
    {
      armor["protectslArm"] = true;
      AP.lArm += armor.data.currentAP.lArm;
    }
    if (armor.data.maxAP.rArm > 0)
    {
      armor["protectsrArm"] = true;
      AP.rArm += armor.data.currentAP.rArm;
    }
    if (armor.data.maxAP.lLeg > 0)
    {
      armor["protectslLeg"] = true;
      AP.lLeg += armor.data.currentAP.lLeg;
    }
    if (armor.data.maxAP.rLeg > 0)
    {
      armor["protectsrLeg"] = true
      AP.rLeg += armor.data.currentAP.rLeg;
    }
    armor.properties = this._separateQualitiesFlaws(this._prepareQualitiesFlaws(armor));
    return armor;
  }

  /* -------------------------------------------- */

  static _prepareQualitiesFlaws(item){
    let qualities = item.data.qualities.value.split(",").map(function(item) {
      if (item)
      {
        item = item.trim();
        if (!(Object.values(WFRP_Utility.qualityList()).includes(item) || (Object.values(WFRP_Utility.flawList()).includes(item)))) //if the quality does not show up in either quality or flaw list, add it
          CONFIG.itemQualities[item.toLowerCase().trim()] = item;
        return item
      }
    });
    let flaws = item.data.flaws.value.split(",").map(function(item) {
      if (item)
      {
        item = item.trim();
        if (!(Object.values(WFRP_Utility.flawList()).includes(item) || (Object.values(WFRP_Utility.qualityList()).includes(item)))) //if the quality does not show up in either quality or flaw list, add it
          CONFIG.itemFlaws[item.toLowerCase().trim()] = item;
        return item;
      }
    });


    if (!item.data.special.value)
      return qualities.concat(flaws).sort().filter(p => !!p);
    else
      return qualities.concat(flaws).sort().concat("Special").filter(p => !!p);

  }

  /* -------------------------------------------- */


  static _separateQualitiesFlaws(properties){
    let qualities = [],
        flaws = [],
        special = [];
    let allQualities = Object.values(this.qualityList());
    let allFlaws = Object.values(this.flawList());
    for (let prop of properties)
    {
      if (allQualities.includes(prop.split(" ")[0]))
        qualities.push(prop);
      else if (allFlaws.includes(prop.split(" ")[0]))
        flaws.push(prop);
      else
        special.push(prop);
    }
    return {qualities : qualities,flaws : flaws, special : special}
  }

  /* -------------------------------------------- */

  static _calculateArmorPenalties(actorData, armorList){
    // Parsing armor penalties for the combat tab
    let armorPenaltiesString = "";
    let wearingMail = false;
    let wearingPlate = false;
    for (let a of armorList)
    {
      armorPenaltiesString += a.data.penalty.value + " ";
      if (a.data.armorType.value == "mail")
        wearingMail = true;
      if (a.data.armorType.value == "plate")
        wearingPlate = true;
    }

    if (wearingMail || wearingPlate)
    {
      let stealthPenaltyValue = 0;
      if (wearingMail)
        stealthPenaltyValue += -10;
      if (wearingPlate)
        stealthPenaltyValue += -10;

      armorPenaltiesString += (stealthPenaltyValue + " Stealth");
    }
    return armorPenaltiesString;
  }

  /* -------------------------------------------- */

  static _calculateRangeOrDamage(actorData, formula){
    try {formula = formula.toLowerCase();}
    catch {return formula}

    for(let ch in actorData.data.characteristics)
    {
      if (formula.includes(ch.concat('b')))
      {
        formula = formula.replace(ch.concat('b'), actorData.data.characteristics[ch].bonus.toString());
      }
    }
    formula = formula.replace('x', '*');

    return eval(formula);
  }

  /* -------------------------------------------- */

  static _prepareWeaponWithAmmo(actorData, weapon){
    let ammo = weapon.ammo.find(a => a.id == weapon.data.currentAmmo.value);
    if (!ammo)
      return;

    let ammoProperties = this._prepareQualitiesFlaws(ammo);           // Skip undefined
    let specialPropInd =  ammoProperties.indexOf(ammoProperties.find(p => p && p.toLowerCase() == "special"));
    if (specialPropInd != -1)
      ammoProperties[specialPropInd] = ammoProperties[specialPropInd] + " Ammo"

    let ammoRange = ammo.data.range.value || "0";
    let ammoDamage = ammo.data.damage.value || "0";

    if (ammoRange.toLowerCase() == "as weapon")
    {
      // Do nothing to weapon's range
    }
    else if (ammoRange.toLowerCase() == "half weapon")
    {
      weapon.data.range.value /= 2;
    }
    else if (ammoRange.toLowerCase() == "third weapon")
    {
      weapon.data.range.value /= 3;
    }
    else if (ammoRange.toLowerCase() == "quarter weapon")
    {
      weapon.data.range.value /= 4;
    }
    else if (ammoRange.toLowerCase() == "twice weapon")
    {
      weapon.data.range.value *= 2;
    }
    else
      weapon.data.range.value += eval(ammoRange)

    weapon.data.damage.rangedValue += eval(ammoDamage);

    // The following code finds qualities or flaws of the ammo that add to the weapon's qualities
    // Example: Blast +1 should turn a weapon's Blast 4 into Blast 5
    ammoProperties = ammoProperties.filter(p => p != undefined);
    let propertyChange = ammoProperties.filter(p => p.includes("+") || p.includes("-")); // Properties that increase or decrease another (Blast +1, Blast -1)

    // Normal properties (Impale, Penetrating)
    let propertiesToAdd = ammoProperties.filter(p => !(p.includes("+") || p.includes("-")));

    for (let inc of propertyChange)
    {
      let index = inc.indexOf(" ");
      let property = inc.substring(0, index).trim();
      let value = inc.substring(index, inc.length);

      if (weapon.properties.find(p => p.includes(property)))
      {
        let basePropertyIndex = weapon.properties.findIndex(p => p.includes(property))
        let baseValue = weapon.properties[basePropertyIndex].split(" ")[1];
        let newValue = eval(baseValue + value)

        weapon.properties[basePropertyIndex] = `${property} ${newValue}`;
      }
      else
      {
        propertiesToAdd.push(property + " " + value);
      }
    }

    weapon.properties = weapon.properties.concat(propertiesToAdd);
  }

  /* -------------------------------------------- */

  static _calculateSpellRangeOrDuration(actorData, formula, aoe=false){
    formula = formula.toLowerCase();

    if (formula != "you" && formula != "special" && formula != "instant")
    {
      for(let ch in actorData.data.characteristics)
      {

        if (formula.includes(CONFIG.characteristics[ch].toLowerCase()))
        {
          if (formula.includes('bonus'))
          {
            formula = formula.replace(CONFIG.characteristics[ch].toLowerCase().concat(" bonus"),  actorData.data.characteristics[ch].bonus);
          }
          else
          {
            formula = formula.replace(CONFIG.characteristics[ch].toLowerCase(),  actorData.data.characteristics[ch].value);
          }
        }
      }
    }

    if (aoe)
      formula = "AoE (" + formula.capitalize() + ")";
    return formula.capitalize();
  }

  static _calculateSpellDamage(actorData, formula, isMagicMissile){
    formula = formula.toLowerCase();

    if (isMagicMissile)
    {
      formula += "+ willpower bonus"
    }

    for(let ch in actorData.data.characteristics)
    {

      while (formula.includes(actorData.data.characteristics[ch].label.toLowerCase()))
      {
        if (formula.includes('bonus'))
        {
          formula = formula.replace(CONFIG.characteristics[ch].toLowerCase().concat(" bonus"),  actorData.data.characteristics[ch].bonus);
        }
        else
        {
          formula = formula.replace(CONFIG.characteristics[ch].toLowerCase(),  actorData.data.characteristics[ch].value);
        }
      }
    }

    return eval(formula);
  }

  /* -------------------------------------------- */

  /**
   * Roll characteristics given a species
   * @param {string} species      Key or value for species in CONFIG
   * @param {bool} average           Take average or not
   */
  static speciesCharacteristics(species, average)
  {
    let characteristics = {};
    let characteristicFormulae = CONFIG.speciesCharacteristics[species];
    try
    {
      if(!characteristicFormulae) // If input species was not a valid key, try finding it as a value
        characteristicFormulae = CONFIG.speciesCharacteristics[this.findKey(species, CONFIG.species)]
    }
    catch (error)
    {
      ui.notifications.info("Could not find species " + species)
      console.log("Could not find species " + species + ": " + error);
      throw error
    }

    for (let char in CONFIG.characteristics)
    {
      if (average)
      {
        characteristics[char] = parseInt(characteristicFormulae[char].split("+")[1]) + 10
      }
      else
      {
        characteristics[char] = new Roll(characteristicFormulae[char]).roll().total;
      }
    }
    return characteristics
  }

  /* -------------------------------------------- */

  static speciesMovement(species)
  {
    let move = CONFIG.speciesMovement[species];
    if(!move) // If input species was not a valid key, try finding it as a value
     move = CONFIG.speciesMovement[this.findKey(species, CONFIG.species)]
    return move;
  }

  /* -------------------------------------------- */

  static findKey(value, obj)
  {
    for (let key in obj)
    {
      if (obj[key] == value)
        return key;
    }
    throw "Could not find key corresponding to " + value
  }

  /* -------------------------------------------- */

  static async findSkill(skillName)
  {
    let skillList = [];
    let pack = game.packs.find(p => p.collection == "wfrp4e.skills")
    await pack.getIndex().then(index => skillList = index);
    // Search for specific skill (won't find unlisted specializations)
    let searchResult = skillList.find(s => s.name == skillName)
    if (!searchResult)
      searchResult = skillList.find(s => s.name.split("(")[0].trim() == skillName.split("(")[0].trim())

    if (!searchResult)
      throw "Could not find skill (or specialization of) " + skillName + " in compendum"

    let dbSkill;
    await pack.getEntity(searchResult.id).then(packSkill => dbSkill = packSkill);
    dbSkill.data.name = skillName; // This is important if a specialized skill wasn't found. Without it, <Skill ()> would be added intsead of <Skill (Specialization)>
    return dbSkill;

  }

  /* -------------------------------------------- */

  static async findTalent(talentName)
  {
    let talentList = [];
    let pack = game.packs.find(p => p.collection == "wfrp4e.talents")
    await pack.getIndex().then(index => talentList = index);
    // Search for specific skill (won't find unlisted specializations)
    let searchResult = talentList.find(t => t.name == talentName)
    if (!searchResult)
      searchResult = talentList.find(t => t.name.split("(")[0].trim() == talentName.split("(")[0].trim())

    if (!searchResult)
      throw "Could not find skill (or specialization of) " + talentName + " in compendum"

    let dbTalent;
    await pack.getEntity(searchResult.id).then(packTalent  => dbTalent = packTalent);
    dbTalent.data.name = talentName; // This is important if a specialized skill wasn't found. Without it, <Skill ()> would be added intsead of <Skill (Specialization)>
    return dbTalent;

  }

  /* -------------------------------------------- */

  static nameSorter(a, b){
    if (a.name.toLowerCase() < b.name.toLowerCase())
      return -1;
    if (a.name.toLowerCase() > b.name.toLowerCase())
      return 1;
    return 0;
  }

  /* -------------------------------------------- */

  static qualityList()
  {
    let weapon = duplicate(CONFIG.weaponQualities);
    let armor = duplicate(CONFIG.armorQualities);
    let item = duplicate(CONFIG.itemQualities);
    let list = mergeObject(weapon,mergeObject(item, armor))
    return list;
  }

  /* -------------------------------------------- */

  static flawList()
  {
    let weapon = duplicate(CONFIG.weaponFlaws);
    let armor = duplicate(CONFIG.armorFlaws);
    let item = duplicate(CONFIG.itemFlaws);
    let list = mergeObject(weapon,mergeObject(item, armor))
    return list;
  }

  /* -------------------------------------------- */

  static _calculateAdvCost(currentAdvances, type)
  {
    let index = Math.ceil((currentAdvances / 5) - 1);
    index = index < 0 ? 0 : index; // min 0

    if (index >= CONFIG.xpCost[type].length)
      return CONFIG.xpCost[CONFIG.xpCost.length-1];
    return CONFIG.xpCost[type][index];
  }


  static displayStatus(tokenId)
  {
    let token = canvas.tokens.get(tokenId);
    let effects = token.data.effects;
    let conditions = {}
    effects = effects.map(function(effect) {

      let isNumeric = !isNaN(effect[effect.indexOf(".") - 1])

      if (isNumeric)
      {
        effect = effect.substring(effect.lastIndexOf("/")+1)
        let effectNum = effect.substring(effect.length-5, effect.length-4)
        effect = effect.substring(0, effect.length-5);
        if (conditions[effect.toString()])
          conditions[effect.toString()] += parseInt(effectNum);
        else
          conditions[effect.toString()] = parseInt(effectNum);
      }

      else
      {
        effect = effect.substring(effect.lastIndexOf("/")+1).substring(0, effect.length-4);
        effect = effect.substring(0, effect.length-4);
        conditions[effect] = true;

      }

   })

   let displayConditions = [];
   for (let c in conditions)
   {
     let displayValue = (CONFIG.conditions[c])
     if (typeof conditions[c] !== "boolean")
      displayValue += " " + conditions[c]
    displayConditions.push(displayValue);
   }


    let chatOptions = {rollMode :  game.settings.get("core", "rollMode")};
    if ( ["gmroll", "blindroll"].includes(chatOptions.rollMode) ) chatOptions["whisper"] = ChatMessage.getWhisperIDs("GM");
    if ( chatOptions.rollMode === "blindroll" ) chatOptions["blind"] = true;
    chatOptions["template"] = "public/systems/wfrp4e/templates/chat/combat-status.html"


    let chatData = {
      name : token.name,
      conditions : displayConditions,
      modifiers : token.actor.data.flags.modifier
    }


   return renderTemplate(chatOptions.template, chatData).then(html => {
      chatOptions["user"] = game.user._id

      // Emit the HTML as a chat message
      chatOptions["content"] = html;
	  chatOptions["type"] = 0;
      ChatMessage.create(chatOptions, false);
      return html;
    });
  }

}

  /* -------------------------------------------- */

class WFRP_Tables {

  static rollTable(table, options = {})
  {
    let modifier = options.modifier || 0;
    let minOne = options.minOne || false;
    let maxSize = options.maxSize || false;

    table = table.toLowerCase();
    if (this[table])
    {
      // cap at 100
      let die = this[table].die;
      let tableSize = this[table].rows.length - 1;
      if (!die)
        die = `1d${tableSize}`;
      let roll = new Roll(`${die} + @modifier`, {modifier}).roll();
      let rollValue = roll.total;
      let displayTotal = roll.result;
      if (rollValue <= 0 && minOne)
        rollValue = 1;

      else if (rollValue <= 0)
        return {roll : rollValue};

      if (rollValue > tableSize)
        rollValue = tableSize;

      if (table == "scatter")
      {
        if (roll.total <= 8)
        {
          let distRoll = new Roll('2d10').roll().total;
          return {roll : roll.total, dist : distRoll}
        }
        else
          return {roll : roll.total}
      }
      return mergeObject(this[table].rows[rollValue], ({roll : displayTotal}));
    }
    else
    {
    }
  }

  /* -------------------------------------------- */

  static generalizeTable (table)
  {
    table = table.toLowerCase();
    table = table.replace("lleg", "leg");
    table = table.replace("rleg", "leg");
    table = table.replace("rarm", "arm");
    table = table.replace("larm", "arm");
    return table;
  }

  /* -------------------------------------------- */

  // Wrapper for rollTable to format rolls from chat commands nicely
  static formatChatRoll (table, options = {})
  {
    table = this.generalizeTable(table);
    let result = this.rollTable(table, options);
    try{
    if (result.roll <= 0 && !options.minOne)
      return `Roll: ${result.roll} - canceled`
    }
    catch {}
    switch (table)
    {
      case "hitloc":
        return `<b>${this[table].name}</b><br>` + result.description;
      case "crithead":
      case "critbody":
      case "critarm":
      case "critleg":
      case "crit":
        return `<b>${this[table].name}</b><br><b>${result.name}</b><br><b>Wounds:</b> ${result.wounds}<br><b>Description: </b>${result.description} (${result.roll})`

      case "minormis":
      case "majormis":
      case "event":
      case "wrath":
      case "travel":
      case "mutatephys":
      case "mutatemental":
        return `<b>${this[table].name}</b><br><b>${result.name}</b><br>${result.description} (${result.roll})`;

      case "doom":
        return `<b>The Prophet Speaketh</b><br>${result.description} (${result.roll})`;

      case "oops":
         return `<b>Oops!</b><br>${result.description} (${result.roll})`;

      case "winds":
          return `<b>The Swirling Winds</b><br> <b>Roll:</b> ${eval(result.roll)} <br> <b>Modifier: </b> ${result.modifier}`;

      case "scatter":
        let tableHtml = '<table class = "scatter-table">' +
        " <tr>"+
        "<td position='1'> "+
        "</td>"+
        "<td position='2'> "+
        "</td>"+
        "<td position='3'> "+
        "</td>"+
        "</tr>"+
        " <tr>"+
        "<td position='4'> "+
        "</td>"+
        "<td position='10'> T"+
        "</td>"+
        "<td position='5'> "+
        "</td>"+
        "</tr>"+
        " <tr>"+
        "<td position='6'> "+
        "</td>"+
        "<td position='7'> "+
        "</td>"+
        "<td position='8'> "+
        "</td>"+
        "</tr>"+
      "</table>"
      if (result.roll == 9)
       tableHtml += "At your feet";
      else if (result.roll == 10)
        tableHtml += "At their feet";
      else
        tableHtml += "Note: Distance can be no more than half the distance between you and the target"
      tableHtml = tableHtml.replace(`position='${result.roll}'`, "class='selected-position'")
      if (result.dist)
        tableHtml = tableHtml.replace("'selected-position'>", `'selected-position'> ${result.dist} yards`)

      return tableHtml;

      default:
        try {
          if (result)
          {
            let html = "";
            for (let part in result)
            {
              if (part == "name")
                html += `<b>${result[part]}</b><br>`
              else if (part == "roll")
                html += "<b>Roll</b>: "+ eval(result[part])
              else
                html += result[part] + "<br>"
            }
            return html;

          }
          else
            throw ""
        }
        catch
        {
          return "<b><code>/table</code> Commands</b><br>"+
          "<a data-table='hitloc' class='table-click'><code>hitloc</code> - Hit Location<br></a>"+
          "<a data-table='crithead' class='table-click'><code>crithead</code> - Head Critical Hits<br></a>"+
          "<a data-table='critbody' class='table-click'><code>critbody</code> - Body Critical Hits<br></a>"+
          "<a data-table='critarm' class='table-click'><code>critarm</code> - Arm Critical Hits<br></a>"+
          "<a data-table='critleg' class='table-click'><code>critleg</code> - Leg Critical Hits<br></a>"+
          "<a data-table='oops' class='table-click'><code>oops</code> - Oops!<br></a>"+
          "<a data-table='minormis' class='table-click'><code>minormis</code> - Minor Miscast<br></a>"+
          "<a data-table='majormis' class='table-click'><code>majormis</code> - Major Miscast<br></a>"+
          "<a data-table='wrath' class='table-click'><code>wrath</code> - Wrath of the Gods<br></a>"+
          "<a data-table='mutatephys' class='table-click'><code>mutatephys</code> - Physical Mutation<br></a>"+
          "<a data-table='mutatemental' class='table-click'><code>mutatemental</code> - Mental Mutation<br></a>"+
          "<a data-table='event' class='table-click'><code>event</code> - Downtime Event<br></a>"+
          "<a data-table='travel' class='table-click'><code>travel</code> - Downtime Event<br></a>"+
          "<a data-table='scatter' class='table-click'><code>scatter</code> - Scatter Direction<br></a>"+
          "<a data-table='doom' class='table-click'><code>doom</code> - Dooming<br></a>"+
          "<a data-table='winds' class='table-click'><code>winds</code> - The Swirling Winds<br></a>"
        }
    }
  }
}

Hooks.on("updateCombat", (combat) => {
  if (game.user.isGM && combat.data.round != 0 && combat.turns && combat.data.active)
  {
    let turn = combat.turns.find(t => t.tokenId == combat.current.tokenId)

    if (game.settings.get("wfrp4e", "statusOnTurnStart"))
      WFRP_Utility.displayStatus(turn.token.id);

    if (game.settings.get("wfrp4e", "focusOnTurnStart"))
    {
      canvas.tokens.get(turn.token.id).control();
      canvas.tokens.cycleTokens(1, true);
    }
  }
})

Hooks.on("deleteCombat", async (combat) => {
  for (let turn of combat.turns)
  {
    let actor = canvas.tokens.get(turn.tokenId).actor;
    await actor.update({"data.status.advantage.value" : 0})
  }
})

Hooks.on("getCombatTrackerEntryContext", (html, options) => {
  options.push(
  {
    name: "Status",
    condition: true,
    icon: '<i class="far fa-question-circle"></i>',
    callback: target => {
      WFRP_Utility.displayStatus(target.attr("data-token-id"));
      $(`#sidebar-tabs`).find(`.item[data-tab="chat"]`).click();
    }
  })
})
